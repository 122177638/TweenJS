{"version":3,"names":[],"mappings":"","sources":["tweenjs.cjs.js"],"sourcesContent":["/**\n * @license tweenjs\n * Visit http://createjs.com for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar asyncGenerator = function() {\n  function AwaitValue(value) {\n    this.value = value\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n        if (back) {\n          back = back.next = request\n        } else {\n          front = back = request;\n          resume(key, arg)\n        }\n      })\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function(arg) {\n            resume(\"next\", arg)\n          }, function(arg) {\n            resume(\"throw\", arg)\n          })\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value)\n        }\n      } catch (err) {\n        settle(\"throw\", err)\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break\n      }\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg)\n      } else {\n        back = null\n      }\n    }\n    this._invoke = send;\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined\n    }\n  }\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this\n    }\n  }\n  AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke(\"next\", arg)\n  };\n  AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke(\"throw\", arg)\n  };\n  AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke(\"return\", arg)\n  };\n  return {\n    wrap: function(fn) {\n      return function() {\n        return new AsyncGenerator(fn.apply(this, arguments))\n      }\n    },\n    await: function(value) {\n      return new AwaitValue(value)\n    }\n  }\n}();\nvar classCallCheck = function(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\")\n  }\n};\nvar createClass = function() {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor)\n    }\n  }\n  return function(Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor\n  }\n}();\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n    if (parent === null) {\n      return undefined\n    } else {\n      return get$1(parent, property, receiver)\n    }\n  } else if (\"value\" in desc) {\n    return desc.value\n  } else {\n    var getter = desc.get;\n    if (getter === undefined) {\n      return undefined\n    }\n    return getter.call(receiver)\n  }\n};\nvar inherits = function(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass)\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass\n};\nvar possibleConstructorReturn = function(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self\n};\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n    if (parent !== null) {\n      set$1(parent, property, value, receiver)\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value\n  } else {\n    var setter = desc.set;\n    if (setter !== undefined) {\n      setter.call(receiver, value)\n    }\n  }\n  return value\n};\n/**\n * A collection of classes that are shared across the CreateJS libraries.\n * Classes required by a library are compiled with that library.\n *\n * @module CreateJS\n * @main CreateJS\n */\n/**\n * Contains properties and methods shared by all events for use with {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n * Note that Event objects are often reused, so you should never\n * rely on an event object's state outside of the call stack it was received in.\n *\n * @class Event\n * @module CreateJS\n */\nvar Event = function() {\n  // constructor:\n  /**\n   * @param {String} type The event type.\n   * @param {Boolean} [bubbles=false] Indicates whether the event will bubble through the display list.\n   * @param {Boolean} [cancelable=false] Indicates whether the default behaviour of this event can be cancelled.\n   * @constructor\n   */\n  function Event(type) {\n    var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, Event);\n    /**\n     * The type of event.\n     * @property type\n     * @type String\n     */\n    this.type = type;\n    /**\n     * The object that generated an event.\n     * @property target\n     * @type Object\n     * @default null\n     * @readonly\n     */\n    this.target = null;\n    /**\n     * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n     * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n     * is generated from childObj, then a listener on parentObj would receive the event with\n     * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n     * @property currentTarget\n     * @type Object\n     * @default null\n     * @readonly\n     */\n    this.currentTarget = null;\n    /**\n     * For bubbling events, this indicates the current event phase:<OL>\n     * \t<LI> capture phase: starting from the top parent to the target</LI>\n     * \t<LI> at target phase: currently being dispatched from the target</LI>\n     * \t<LI> bubbling phase: from the target to the top parent</LI>\n     * </OL>\n     * @property eventPhase\n     * @type Number\n     * @default 0\n     * @readonly\n     */\n    this.eventPhase = 0;\n    /**\n     * Indicates whether the event will bubble through the display list.\n     * @property bubbles\n     * @type Boolean\n     * @default false\n     * @readonly\n     */\n    this.bubbles = bubbles;\n    /**\n     * Indicates whether the default behaviour of this event can be cancelled via\n     * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n     * @property cancelable\n     * @type Boolean\n     * @default false\n     * @readonly\n     */\n    this.cancelable = cancelable;\n    /**\n     * The epoch time at which this event was created.\n     * @property timeStamp\n     * @type Number\n     * @default 0\n     * @readonly\n     */\n    this.timeStamp = (new Date).getTime();\n    /**\n     * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n     * on this event.\n     * @property defaultPrevented\n     * @type Boolean\n     * @default false\n     * @readonly\n     */\n    this.defaultPrevented = false;\n    /**\n     * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n     * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n     * @property propagationStopped\n     * @type Boolean\n     * @default false\n     * @readonly\n     */\n    this.propagationStopped = false;\n    /**\n     * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n     * on this event.\n     * @property immediatePropagationStopped\n     * @type Boolean\n     * @default false\n     * @readonly\n     */\n    this.immediatePropagationStopped = false;\n    /**\n     * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n     * @property removed\n     * @type Boolean\n     * @default false\n     * @readonly\n     */\n    this.removed = false\n  }\n  // public methods:\n  /**\n   * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true if the event is cancelable.\n   * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n   * cancel the default behaviour associated with the event.\n   * @method preventDefault\n   */\n  Event.prototype.preventDefault = function preventDefault() {\n    this.defaultPrevented = this.cancelable\n  };\n  /**\n   * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n   * Mirrors the DOM event standard.\n   * @method stopPropagation\n   */\n  Event.prototype.stopPropagation = function stopPropagation() {\n    this.propagationStopped = true\n  };\n  /**\n   * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n   * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n   * Mirrors the DOM event standard.\n   * @method stopImmediatePropagation\n   */\n  Event.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  };\n  /**\n   * Causes the active listener to be removed via removeEventListener();\n   *\n   * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n   * \t\t\t// do stuff...\n   * \t\t\tevt.remove(); // removes this listener.\n   * \t\t});\n   *\n   * @method remove\n   */\n  Event.prototype.remove = function remove() {\n    this.removed = true\n  };\n  /**\n   * Returns a clone of the Event instance.\n   * @method clone\n   * @return {Event} a clone of the Event instance.\n   */\n  Event.prototype.clone = function clone() {\n    var event = new Event(this.type, this.bubbles, this.cancelable);\n    for (var n in this) {\n      if (this.hasOwnProperty(n)) {\n        event[n] = this[n]\n      }\n    }\n    return event\n  };\n  /**\n   * Provides a chainable shortcut method for setting a number of properties on the instance.\n   *\n   * @method set\n   * @param {Object} props A generic object containing properties to copy to the instance.\n   * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n   * @chainable\n   */\n  Event.prototype.set = function set(props) {\n    for (var n in props) {\n      this[n] = props[n]\n    }\n    return this\n  };\n  /**\n   * Returns a string representation of this object.\n   * @method toString\n   * @return {String} a string representation of the instance.\n   */\n  Event.prototype.toString = function toString() {\n    return \"[\" + this.constructor.name + \" (type=\" + this.type + \")]\"\n  };\n  return Event\n}();\n/**\n * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n *\n * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\n *\n * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n *\n * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\n * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The\n * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\n * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\n *\n * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\n * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also\n * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\n *\n * <h4>Example</h4>\n * Add EventDispatcher capabilities to the \"MyClass\" class.\n *\n *      EventDispatcher.initialize(MyClass.prototype);\n *\n * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\n *\n *      instance.addEventListener(\"eventName\", handlerMethod);\n *      function handlerMethod(event) {\n *          console.log(event.target + \" Was Clicked\");\n *      }\n *\n * <b>Maintaining proper scope</b><br />\n * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\n * method to subscribe to events simplifies this.\n *\n *      instance.addEventListener(\"click\", function(event) {\n *          console.log(instance == this); // false, scope is ambiguous.\n *      });\n *\n *      instance.on(\"click\", function(event) {\n *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\n *      });\n *\n * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.\n *\n *\n * @class EventDispatcher\n * @module CreateJS\n */\nvar EventDispatcher = function() {\n  // static methods:\n  /**\n   * Static initializer to mix EventDispatcher methods into a target object or prototype.\n   *\n   * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n   * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\n   *\n   * @method initialize\n   * @static\n   * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n   * prototype.\n   */\n  EventDispatcher.initialize = function initialize(target) {\n    var p = EventDispatcher.prototype;\n    target.addEventListener = p.addEventListener;\n    target.on = p.on;\n    target.removeEventListener = target.off = p.removeEventListener;\n    target.removeAllEventListeners = p.removeAllEventListeners;\n    target.hasEventListener = p.hasEventListener;\n    target.dispatchEvent = p.dispatchEvent;\n    target._dispatchEvent = p._dispatchEvent;\n    target.willTrigger = p.willTrigger\n  };\n  // constructor:\n  /**\n   * @constructor\n   */\n  function EventDispatcher() {\n    classCallCheck(this, EventDispatcher);\n    /**\n     * @protected\n     * @property _listeners\n     * @type Object\n     */\n    this._listeners = null;\n    /**\n     * @protected\n     * @property _captureListeners\n     * @type Object\n     */\n    this._captureListeners = null\n  }\n  // public methods:\n  /**\n   * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n   * multiple callbacks getting fired.\n   *\n   * <h4>Example</h4>\n   *\n   *      displayObject.addEventListener(\"click\", handleClick);\n   *      function handleClick(event) {\n   *         // Click happened.\n   *      }\n   *\n   * @method addEventListener\n   * @param {String} type The string type of the event.\n   * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n   * the event is dispatched.\n   * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   * @return {Function | Object} Returns the listener for chaining or assignment.\n   */\n  EventDispatcher.prototype.addEventListener = function addEventListener(type, listener, useCapture) {\n    var listeners = void 0;\n    if (useCapture) {\n      listeners = this._captureListeners = this._captureListeners || {}\n    } else {\n      listeners = this._listeners = this._listeners || {}\n    }\n    var arr = listeners[type];\n    if (arr) {\n      this.removeEventListener(type, listener, useCapture)\n    }\n    arr = listeners[type]; // remove may have deleted the array\n    if (!arr) {\n      listeners[type] = [listener]\n    } else {\n      arr.push(listener)\n    }\n    return listener\n  };\n  /**\n   * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n   * only run once, associate arbitrary data with the listener, and remove the listener.\n   *\n   * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n   * The wrapper function is returned for use with `removeEventListener` (or `off`).\n   *\n   * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n   * {{#crossLink \"Event/remove\"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n   * to `on` with the same params will create multiple listeners.\n   *\n   * <h4>Example</h4>\n   *\n   * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\n   * \t\tfunction handleClick(evt, data) {\n   * \t\t\tdata.count -= 1;\n   * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\n   * \t\t\tif (data.count == 0) {\n   * \t\t\t\talert(\"clicked 3 times!\");\n   * \t\t\t\tmyBtn.off(\"click\", listener);\n   * \t\t\t\t// alternately: evt.remove();\n   * \t\t\t}\n   * \t\t}\n   *\n   * @method on\n   * @param {String} type The string type of the event.\n   * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n   * the event is dispatched.\n   * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n   * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n   * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n   * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n   */\n  EventDispatcher.prototype.on = function on(type, listener) {\n    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var useCapture = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    if (listener.handleEvent) {\n      scope = scope || listener;\n      listener = listener.handleEvent\n    }\n    scope = scope || this;\n    return this.addEventListener(type, function(evt) {\n      listener.call(scope, evt, data);\n      once && evt.remove()\n    }, useCapture)\n  };\n  /**\n   * Removes the specified event listener.\n   *\n   * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n   * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n   * closure will not work.\n   *\n   * <h4>Example</h4>\n   *\n   *      displayObject.removeEventListener(\"click\", handleClick);\n   *\n   * @method removeEventListener\n   * @param {String} type The string type of the event.\n   * @param {Function | Object} listener The listener function or object.\n   * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   */\n  EventDispatcher.prototype.removeEventListener = function removeEventListener(type, listener, useCapture) {\n    var listeners = useCapture ? this._captureListeners : this._listeners;\n    if (!listeners) {\n      return\n    }\n    var arr = listeners[type];\n    if (!arr) {\n      return\n    }\n    var l = arr.length;\n    for (var i = 0; i < l; i++) {\n      if (arr[i] == listener) {\n        if (l == 1) {\n          delete listeners[type]\n        } else {\n          arr.splice(i, 1)\n        }\n        break\n      }\n    }\n  };\n  /**\n   * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n   * .on method.\n   *\n   * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See\n   * {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} for an example.\n   *\n   * @method off\n   * @param {String} type The string type of the event.\n   * @param {Function | Object} listener The listener function or object.\n   * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n   */\n  EventDispatcher.prototype.off = function off(type, listener, useCapture) {\n    this.removeEventListener(type, listener, useCapture)\n  };\n  /**\n   * Removes all listeners for the specified type, or all listeners of all types.\n   *\n   * <h4>Example</h4>\n   *\n   *      // Remove all listeners\n   *      displayObject.removeAllEventListeners();\n   *\n   *      // Remove all click listeners\n   *      displayObject.removeAllEventListeners(\"click\");\n   *\n   * @method removeAllEventListeners\n   * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n   */\n  EventDispatcher.prototype.removeAllEventListeners = function removeAllEventListeners(type) {\n    if (!type) {\n      this._listeners = this._captureListeners = null\n    } else {\n      if (this._listeners) {\n        delete this._listeners[type]\n      }\n      if (this._captureListeners) {\n        delete this._captureListeners[type]\n      }\n    }\n  };\n  /**\n   * Dispatches the specified event to all listeners.\n   *\n   * <h4>Example</h4>\n   *\n   *      // Use a string event\n   *      this.dispatchEvent(\"complete\");\n   *\n   *      // Use an Event instance\n   *      var event = new createjs.Event(\"progress\");\n   *      this.dispatchEvent(event);\n   *\n   * @method dispatchEvent\n   * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\n   * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n   * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n   * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n   * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\n   * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\n   * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n   */\n  EventDispatcher.prototype.dispatchEvent = function dispatchEvent(eventObj) {\n    var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (typeof eventObj == \"string\") {\n      // skip everything if there's no listeners and it doesn't bubble:\n      var listeners = this._listeners;\n      if (!bubbles && (!listeners || !listeners[eventObj])) {\n        return true\n      }\n      eventObj = new Event(eventObj, bubbles, cancelable)\n    } else if (eventObj.target && eventObj.clone) {\n      // redispatching an active event object, so clone it:\n      eventObj = eventObj.clone()\n    }\n    // TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n    try {\n      eventObj.target = this\n    } catch (e) {} // try/catch allows redispatching of native events\n    if (!eventObj.bubbles || !this.parent) {\n      this._dispatchEvent(eventObj, 2)\n    } else {\n      var top = this,\n        i = void 0;\n      var list = [top];\n      while (top.parent) {\n        list.push(top = top.parent)\n      }\n      var l = list.length;\n      // capture & atTarget\n      for (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) {\n        list[i]._dispatchEvent(eventObj, 1 + (i == 0))\n      }\n      // bubbling\n      for (i = 1; i < l && !eventObj.propagationStopped; i++) {\n        list[i]._dispatchEvent(eventObj, 3)\n      }\n    }\n    return !eventObj.defaultPrevented\n  };\n  /**\n   * Indicates whether there is at least one listener for the specified event type.\n   * @method hasEventListener\n   * @param {String} type The string type of the event.\n   * @return {Boolean} Returns true if there is at least one listener for the specified event.\n   */\n  EventDispatcher.prototype.hasEventListener = function hasEventListener(type) {\n    var listeners = this._listeners,\n      captureListeners = this._captureListeners;\n    return !!(listeners && listeners[type] || captureListeners && captureListeners[type])\n  };\n  /**\n   * Indicates whether there is at least one listener for the specified event type on this object or any of its\n   * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n   * specified type is dispatched from this object, it will trigger at least one listener.\n   *\n   * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\n   * event flow for a listener, not just this object.\n   * @method willTrigger\n   * @param {String} type The string type of the event.\n   * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n   */\n  EventDispatcher.prototype.willTrigger = function willTrigger(type) {\n    var o = this;\n    while (o) {\n      if (o.hasEventListener(type)) {\n        return true\n      }\n      o = o.parent\n    }\n    return false\n  };\n  /**\n   * @method toString\n   * @return {String} a string representation of the instance.\n   */\n  EventDispatcher.prototype.toString = function toString() {\n    return \"[EventDispatcher]\"\n  };\n  // private methods:\n  /**\n   * @method _dispatchEvent\n   * @param {Object | String | Event} eventObj\n   * @param {Object} eventPhase\n   * @protected\n   */\n  EventDispatcher.prototype._dispatchEvent = function _dispatchEvent(eventObj, eventPhase) {\n    var listeners = eventPhase == 1 ? this._captureListeners : this._listeners;\n    var l = void 0;\n    if (eventObj && listeners) {\n      var arr = listeners[eventObj.type];\n      if (!arr || !(l = arr.length)) {\n        return\n      }\n      try {\n        eventObj.currentTarget = this\n      } catch (e) {}\n      try {\n        eventObj.eventPhase = eventPhase\n      } catch (e) {}\n      eventObj.removed = false;\n      arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n      for (var i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {\n        var o = arr[i];\n        if (o.handleEvent) {\n          o.handleEvent(eventObj)\n        } else {\n          o(eventObj)\n        }\n        if (eventObj.removed) {\n          this.off(eventObj.type, o, eventPhase == 1);\n          eventObj.removed = false\n        }\n      }\n    }\n  };\n  return EventDispatcher\n}();\n/**\n * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n * event to be notified when a set time interval has elapsed.\n *\n * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n * can not be instantiated.\n *\n * <h4>Example</h4>\n *\n *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n *      function handleTick(event) {\n *          // Actions carried out each tick (aka frame)\n *          if (!event.paused) {\n *              // Actions carried out when the Ticker is not paused.\n *          }\n *      }\n *\n * @class TickerAPI\n * @extends EventDispatcher\n * @module CreateJS\n */\nvar TickerAPI = function(_EventDispatcher) {\n  inherits(TickerAPI, _EventDispatcher);\n  // constructor:\n  /**\n   * @param name {String} The name assigned to this instance.\n   * @constructor\n   * TODO-ES6: Pass timingMode, maxDelta, paused values as instantiation arguments?\n   */\n  function TickerAPI(name) {\n    classCallCheck(this, TickerAPI);\n    // public properties:\n    /**\n     * The name of this instance.\n     * @property name\n     * @type {String}\n     */\n    var _this = possibleConstructorReturn(this, _EventDispatcher.call(this));\n    _this.name = name;\n    /**\n     * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n     * {{#crossLink \"Ticker/TIMEOUT\"}}{{/crossLink}}, {{#crossLink \"Ticker/RAF\"}}{{/crossLink}}, and\n     * {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} for mode details.\n     * @property timingMode\n     * @type {String}\n     * @default Ticker.TIMEOUT\n     */\n    _this.timingMode = TickerAPI.TIMEOUT;\n    /**\n     * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n     * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n     * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n     * (ex. maxDelta=50 when running at 40fps).\n     *\n     * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n     * when using both delta and other values.\n     *\n     * If 0, there is no maximum.\n     * @property maxDelta\n     * @type {number}\n     * @default 0\n     */\n    _this.maxDelta = 0;\n    /**\n     * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property\n     * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}},\n     * {{#crossLink \"Ticker/getTime\"}}{{/crossLink}}, and {{#crossLink \"Ticker/getEventTime\"}}{{/crossLink}} for more\n     * info.\n     *\n     * <h4>Example</h4>\n     *\n     *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n     *      createjs.Ticker.paused = true;\n     *      function handleTick(event) {\n     *          console.log(event.paused,\n     *          \tcreatejs.Ticker.getTime(false),\n     *          \tcreatejs.Ticker.getTime(true));\n     *      }\n     *\n     * @property paused\n     * @type {Boolean}\n     * @default false\n     */\n    _this.paused = false;\n    // private properties:\n    /**\n     * @property _inited\n     * @type {Boolean}\n     * @protected\n     */\n    _this._inited = false;\n    /**\n     * @property _startTime\n     * @type {Number}\n     * @protected\n     */\n    _this._startTime = 0;\n    /**\n     * @property _pausedTime\n     * @type {Number}\n     * @protected\n     */\n    _this._pausedTime = 0;\n    /**\n     * The number of ticks that have passed\n     * @property _ticks\n     * @type {Number}\n     * @protected\n     */\n    _this._ticks = 0;\n    /**\n     * The number of ticks that have passed while Ticker has been paused\n     * @property _pausedTicks\n     * @type {Number}\n     * @protected\n     */\n    _this._pausedTicks = 0;\n    /**\n     * @property _interval\n     * @type {Number}\n     * @protected\n     */\n    _this._interval = 50;\n    /**\n     * @property _lastTime\n     * @type {Number}\n     * @protected\n     */\n    _this._lastTime = 0;\n    /**\n     * @property _times\n     * @type {Array}\n     * @protected\n     */\n    _this._times = null;\n    /**\n     * @property _tickTimes\n     * @type {Array}\n     * @protected\n     */\n    _this._tickTimes = null;\n    /**\n     * Stores the timeout or requestAnimationFrame id.\n     * @property _timerId\n     * @type {Number}\n     * @protected\n     */\n    _this._timerId = null;\n    /**\n     * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n     * if that property changed and a tick hasn't fired.\n     * @property _raf\n     * @type {Boolean}\n     * @protected\n     */\n    _this._raf = true;\n    return _this\n  }\n  // accessor properties:\n  /**\n   * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n   * Note that actual time between ticks may be more than specified depending on CPU load.\n   * This property is ignored if the ticker is using the `RAF` timing mode.\n   * @property interval\n   * @static\n   * @type {Number}\n   */\n  // public methods:\n  /**\n   * Call createjs.Ticker.create() to get a new TickerAPI instance.\n   * It is not initalized by default and its ticks are not synched with any other instance.\n   *\n   * @param name {String} The name given to the new instance.\n   * @method create\n   * @return {TickerAPI} A new TickerAPI instance.\n   */\n  TickerAPI.prototype.create = function create(name) {\n    return new TickerAPI(name)\n  };\n  /**\n   * Starts the tick. This is called automatically when the first listener is added.\n   * @method init\n   */\n  TickerAPI.prototype.init = function init() {\n    if (this._inited) {\n      return\n    }\n    this._inited = true;\n    this._times = [];\n    this._tickTimes = [];\n    this._startTime = this._getTime();\n    this._times.push(this._lastTime = 0);\n    this._setupTick()\n  };\n  /**\n   * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n   * @method reset\n   */\n  TickerAPI.prototype.reset = function reset() {\n    if (this._raf) {\n      var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n      f && f(this._timerId)\n    } else {\n      clearTimeout(this._timerId)\n    }\n    this.removeAllEventListeners(\"tick\");\n    this._timerId = this._times = this._tickTimes = null;\n    this._startTime = this._lastTime = this._ticks = 0;\n    this._inited = false\n  };\n  /**\n   * Init the Ticker instance if it hasn't been already.\n   * Docced in superclass.\n   */\n  TickerAPI.prototype.addEventListener = function addEventListener(type, listener, useCapture) {\n    !this._inited && this.init();\n    return _EventDispatcher.prototype.addEventListener.call(this, type, listener, useCapture)\n  };\n  /**\n   * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n   * because it only measures the time spent within the tick execution stack.\n   *\n   * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between\n   * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that\n   * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n   *\n   * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n   * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n   * other than the tick is using ~80ms (another script, DOM rendering, etc).\n   * @method getMeasuredTickTime\n   * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n   * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n   * @return {Number} The average time spent in a tick in milliseconds.\n   */\n  TickerAPI.prototype.getMeasuredTickTime = function getMeasuredTickTime(ticks) {\n    var times = this._tickTimes;\n    if (!times || times.length < 1) {\n      return -1\n    }\n    // by default, calculate average for the past ~1 second:\n    ticks = Math.min(times.length, ticks || this.framerate | 0);\n    var ttl = times.reduce(function(a, b) {\n      return a + b\n    }, 0);\n    return ttl / ticks\n  };\n  /**\n   * Returns the actual frames / ticks per second.\n   * @method getMeasuredFPS\n   * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n   * Defaults to the number of ticks per second.\n   * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n   * from the target frames per second.\n   */\n  TickerAPI.prototype.getMeasuredFPS = function getMeasuredFPS(ticks) {\n    var times = this._times;\n    if (!times || times.length < 2) {\n      return -1\n    }\n    // by default, calculate fps for the past ~1 second:\n    ticks = Math.min(times.length - 1, ticks || this.framerate | 0);\n    return 1e3 / ((times[0] - times[ticks]) / ticks)\n  };\n  /**\n   * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink \"Ticker/init\"}}.\n   * Returns -1 if Ticker has not been initialized. For example, you could use\n   * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n   * @method getTime\n   * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n   * If false, the value returned will be total time elapsed since the first tick event listener was added.\n   * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n   */\n  TickerAPI.prototype.getTime = function getTime() {\n    var runTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._startTime ? this._getTime() - (runTime ? this._pausedTime : 0) : -1\n  };\n  /**\n   * Similar to the {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n   * event object.\n   * @method getEventTime\n   * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n   * @returns {number} The time or runTime property from the most recent tick event or -1.\n   */\n  TickerAPI.prototype.getEventTime = function getEventTime() {\n    var runTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._startTime ? (this._lastTime || this._startTime) - (runTime ? this._pausedTime : 0) : -1\n  };\n  /**\n   * Returns the number of ticks that have been broadcast by Ticker.\n   * @method getTicks\n   * @param {Boolean} [pauseable=false] Indicates whether to include ticks that would have been broadcast\n   * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n   * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n   * value.\n   * @return {Number} of ticks that have been broadcast.\n   */\n  TickerAPI.prototype.getTicks = function getTicks() {\n    var pauseable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._ticks - (pauseable ? this._pausedTicks : 0)\n  };\n  // private methods:\n  /**\n   * @method _handleSynch\n   * @protected\n   */\n  TickerAPI.prototype._handleSynch = function _handleSynch() {\n    this._timerId = null;\n    this._setupTick();\n    // run if enough time has elapsed, with a little bit of flexibility to be early:\n    if (this._getTime() - this._lastTime >= (this._interval - 1) * .97) {\n      this._tick()\n    }\n  };\n  /**\n   * @method _handleRAF\n   * @protected\n   */\n  TickerAPI.prototype._handleRAF = function _handleRAF() {\n    this._timerId = null;\n    this._setupTick();\n    this._tick()\n  };\n  /**\n   * @method _handleTimeout\n   * @protected\n   */\n  TickerAPI.prototype._handleTimeout = function _handleTimeout() {\n    this._timerId = null;\n    this._setupTick();\n    this._tick()\n  };\n  /**\n   * @method _setupTick\n   * @protected\n   */\n  TickerAPI.prototype._setupTick = function _setupTick() {\n    if (this._timerId != null) {\n      return\n    } // avoid duplicates\n    var mode = this.timingMode || this._raf && TickerAPI.RAF; // TODO-ES6: Verify that this is desired, since Ticker.useRAF was removed.\n    if (mode == TickerAPI.RAF_SYNCHED || mode == TickerAPI.RAF) {\n      var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n      if (f) {\n        this._timerId = f(mode == TickerAPI.RAF ? this._handleRAF.bind(this) : this._handleSynch.bind(this));\n        this._raf = true;\n        return\n      }\n    }\n    this._raf = false;\n    this._timerId = setTimeout(this._handleTimeout.bind(this), this._interval)\n  };\n  /**\n   * @method _tick\n   * @protected\n   */\n  TickerAPI.prototype._tick = function _tick() {\n    var paused = this.paused;\n    var time = this._getTime();\n    var elapsedTime = time - this._lastTime;\n    this._lastTime = time;\n    this._ticks++;\n    if (paused) {\n      this._pausedTicks++;\n      this._pausedTime += elapsedTime\n    }\n    if (this.hasEventListener(\"tick\")) {\n      var event = new Event(\"tick\");\n      var maxDelta = this.maxDelta;\n      event.delta = maxDelta && elapsedTime > maxDelta ? maxDelta : elapsedTime;\n      event.paused = paused;\n      event.time = time;\n      event.runTime = time - this._pausedTime;\n      this.dispatchEvent(event)\n    }\n    this._tickTimes.unshift(this._getTime() - time);\n    while (this._tickTimes.length > 100) {\n      this._tickTimes.pop()\n    }\n    this._times.unshift(time);\n    while (this._times.length > 100) {\n      this._times.pop()\n    }\n  };\n  /**\n   * @method _getTime\n   * @protected\n   */\n  TickerAPI.prototype._getTime = function _getTime() {\n    var now = window.performance.now;\n    return (now && now.call(performance) || (new Date).getTime()) - this._startTime\n  };\n  createClass(TickerAPI, [{\n    key: \"interval\",\n    get: function get() {\n      return this._interval\n    },\n    set: function set(interval) {\n      this._interval = interval;\n      if (!this._inited) {\n        return\n      }\n      this._setupTick()\n    }\n  }, {\n    key: \"framerate\",\n    get: function get() {\n      return 1e3 / this._interval\n    },\n    set: function set(fps) {\n      this.interval = 1e3 / fps\n    }\n  }]);\n  return TickerAPI\n}(EventDispatcher);\n// constants:\n/**\n * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n * dispatches the tick when the time is within a certain threshold.\n *\n * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n * gaining the benefits of that API (screen synch, background throttling).\n *\n * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n * framerates of 10, 12, 15, 20, and 30 work well.\n *\n * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n * supported.\n * @property RAF_SYNCHED\n * @static\n * @type {String}\n * @default \"synched\"\n * @readonly\n */\nTickerAPI.RAF_SYNCHED = \"synched\";\n/**\n * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n * You can leverage {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} and the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n * event object's \"delta\" properties to make this easier.\n *\n * Falls back on {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n * supported.\n * @property RAF\n * @static\n * @type {String}\n * @default \"raf\"\n * @readonly\n */\nTickerAPI.RAF = \"raf\";\n/**\n * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n * @property TIMEOUT\n * @static\n * @type {String}\n * @default \"timeout\"\n * @readonly\n */\nTickerAPI.TIMEOUT = \"timeout\";\n// events:\n/**\n * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n * {{#crossLink \"Ticker/setPaused\"}}{{/crossLink}}.\n *\n * <h4>Example</h4>\n *\n *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n *      function handleTick(event) {\n *          console.log(\"Paused:\", event.paused, event.delta);\n *      }\n *\n * @event tick\n * @param {Object} target The object that dispatched the event.\n * @param {String} type The event type.\n * @param {Boolean} paused Indicates whether the ticker is currently paused.\n * @param {Number} delta The time elapsed in ms since the last tick.\n * @param {Number} time The total time in ms since Ticker was initialized.\n * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n * \tyou could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n * @since 0.6.0\n */\n/**\n * The Ticker object is a singleton instance of the TickerAPI class.\n * See the {{#crossLink \"TickerAPI\"}}{{/crossLink}} documentation for its usage.\n * @class Ticker\n * @static\n * @module CreateJS\n */\nvar Ticker = new TickerAPI(\"createjs.global\");\n/**\n * Tweens properties for a single target. Methods can be chained to create complex animation sequences:\n *\n * <h4>Example</h4>\n *\n *\tcreatejs.Tween.get(target)\n *\t\t.wait(500)\n *\t\t.to({alpha:0, visible:false}, 1000)\n *\t\t.call(handleComplete);\n *\n * Multiple tweens can share a target, however if they affect the same properties there could be unexpected\n * behaviour. To stop all tweens on an object, use {{#crossLink \"Tween/removeTweens\"}}{{/crossLink}} or pass `override:true`\n * in the props argument.\n *\n * \tcreatejs.Tween.get(target, {override:true}).to({x:100});\n *\n * Subscribe to the {{#crossLink \"Tween/change:event\"}}{{/crossLink}} event to be notified when the tween position changes.\n *\n * \tcreatejs.Tween.get(target, {override:true}).to({x:100}).addEventListener(\"change\", handleChange);\n * \tfunction handleChange(event) {\n * \t\t// The tween changed.\n * \t}\n *\n * See the {{#crossLink \"Tween/get\"}}{{/crossLink}} method also.\n * @class Tween\n * @extends AbstractTween\n * @module TweenJS\n */\nvar Tween = function(_AbstractTween) {\n  inherits(Tween, _AbstractTween);\n  // constructor:\n  /**\n   * @constructor\n   * @param {Object} target The target object that will have its properties tweened.\n   * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n   * Supported props are listed below. These props are set on the corresponding instance properties except where\n   * specified.<UL>\n   *    <LI> `useTicks`</LI>\n   *    <LI> `ignoreGlobalPause`</LI>\n   *    <LI> `loop`</LI>\n   *    <LI> `reversed`</LI>\n   *    <LI> `bounce`</LI>\n   *    <LI> `timeScale`</LI>\n   *    <LI> `pluginData`</LI>\n   *    <LI> `paused`: indicates whether to start the tween paused.</LI>\n   *    <LI> `position`: indicates the initial position for this tween.</LI>\n   *    <LI> `onChange`: adds the specified function as a listener to the `change` event</LI>\n   *    <LI> `onComplete`: adds the specified function as a listener to the `complete` event</LI>\n   *    <LI> `override`: if true, removes all existing tweens for the target</LI>\n   * </UL>\n   */\n  function Tween(target, props) {\n    classCallCheck(this, Tween);\n    // public properties:\n    /**\n     * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general\n     * you specify data by assigning it to a property of `pluginData` with the same name as the plugin.\n     * Note that in many cases, this data is used as soon as the plugin initializes itself for the tween.\n     * As such, this data should be set before the first `to` call in most cases.\n     * @example\n     *\tmyTween.pluginData.SmartRotation = data;\n     *\n     * Most plugins also support a property to disable them for a specific tween. This is typically the plugin name followed by \"_disabled\".\n     * @example\n     *\tmyTween.pluginData.SmartRotation_disabled = true;\n     *\n     * Some plugins also store working data in this object, usually in a property named `_PluginClassName`.\n     * See the documentation for individual plugins for more details.\n     * @property pluginData\n     * @type {Object}\n     */\n    var _this = possibleConstructorReturn(this, _AbstractTween.call(this, props));\n    _this.pluginData = null;\n    /**\n     * The target of this tween. This is the object on which the tweened properties will be changed.\n     * @property target\n     * @type {Object}\n     * @readonly\n     */\n    _this.target = target;\n    /**\n     * Indicates the tween's current position is within a passive wait.\n     * @property passive\n     * @type {Boolean}\n     * @default false\n     * @readonly\n     */\n    _this.passive = false;\n    // private properties:\n    /**\n     * @property _stepHead\n     * @type {TweenStep}\n     * @protected\n     */\n    _this._stepHead = new TweenStep(null, 0, 0, {}, null, true);\n    /**\n     * @property _stepTail\n     * @type {TweenStep}\n     * @protected\n     */\n    _this._stepTail = _this._stepHead;\n    /**\n     * The position within the current step. Used by MovieClip.\n     * @property _stepPosition\n     * @type {Number}\n     * @default 0\n     * @protected\n     */\n    _this._stepPosition = 0;\n    /**\n     * @property _actionHead\n     * @type {TweenAction}\n     * @protected\n     */\n    _this._actionHead = null;\n    /**\n     * @property _actionTail\n     * @type {TweenAction}\n     * @protected\n     */\n    _this._actionTail = null;\n    /**\n     * Plugins added to this tween instance.\n     * @property _plugins\n     * @type Array[Object]\n     * @default null\n     * @protected\n     */\n    _this._plugins = null;\n    /**\n     * Used by plugins to inject new properties.\n     * @property _injected\n     * @type {Object}\n     * @default null\n     * @protected\n     */\n    _this._injected = null;\n    if (props) {\n      _this.pluginData = props.pluginData;\n      if (props.override) {\n        Tween.removeTweens(target)\n      }\n    }\n    if (!_this.pluginData) {\n      _this.pluginData = {}\n    }\n    _this._init(props);\n    return _this\n  }\n  // static methods:\n  /**\n   * Returns a new tween instance. This is functionally identical to using `new Tween(...)`, but may look cleaner\n   * with the chained syntax of TweenJS.\n   * <h4>Example</h4>\n   *\n   *\tvar tween = createjs.Tween.get(target).to({x:100}, 500);\n   *\t// equivalent to:\n   *\tvar tween = new createjs.Tween(target).to({x:100}, 500);\n   *\n   * @method get\n   * @param {Object} target The target object that will have its properties tweened.\n   * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n   * Supported props are listed below. These props are set on the corresponding instance properties except where\n   * specified.<UL>\n   *    <LI> `useTicks`</LI>\n   *    <LI> `ignoreGlobalPause`</LI>\n   *    <LI> `loop`</LI>\n   *    <LI> `reversed`</LI>\n   *    <LI> `bounce`</LI>\n   *    <LI> `timeScale`</LI>\n   *    <LI> `pluginData`</LI>\n   *    <LI> `paused`: indicates whether to start the tween paused.</LI>\n   *    <LI> `position`: indicates the initial position for this tween.</LI>\n   *    <LI> `onChange`: adds the specified function as a listener to the `change` event</LI>\n   *    <LI> `onComplete`: adds the specified function as a listener to the `complete` event</LI>\n   *    <LI> `override`: if true, removes all existing tweens for the target</LI>\n   * </UL>\n   * @return {Tween} A reference to the created tween.\n   * @static\n   */\n  Tween.get = function get(target, props) {\n    return new Tween(target, props)\n  };\n  /**\n   * Advances all tweens. This typically uses the {{#crossLink \"Ticker\"}}{{/crossLink}} class, but you can call it\n   * manually if you prefer to use your own \"heartbeat\" implementation.\n   * @method tick\n   * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have\n   * `useTicks` set to true.\n   * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink \"Tween/ignoreGlobalPause:property\"}}{{/crossLink}}\n   * will ignore this, but all others will pause if this is `true`.\n   * @static\n   */\n  Tween.tick = function tick(delta, paused) {\n    var tween = Tween._tweenHead;\n    while (tween) {\n      var next = tween._next; // in case it completes and wipes its _next property\n      if (paused && !tween.ignoreGlobalPause || tween._paused) {} else {\n        tween.advance(tween.useTicks ? 1 : delta)\n      }\n      tween = next\n    }\n  };\n  /**\n   * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle\n   * {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}} events from the createjs {{#crossLink \"Ticker\"}}{{/crossLink}}.\n   * No other events are handled in Tween.\n   * @method handleEvent\n   * @param {Object} event An event object passed in by the {{#crossLink \"EventDispatcher\"}}{{/crossLink}}. Will\n   * usually be of type \"tick\".\n   * @private\n   * @static\n   * @since 0.4.2\n   */\n  Tween.handleEvent = function handleEvent(event) {\n    if (event.type === \"tick\") {\n      this.tick(event.delta, event.paused)\n    }\n  };\n  /**\n   * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`\n   * property is `true`.\n   * @method removeTweens\n   * @param {Object} target The target object to remove existing tweens from.\n   * @static\n   */\n  Tween.removeTweens = function removeTweens(target) {\n    if (!target.tweenjs_count) {\n      return\n    }\n    var tween = Tween._tweenHead;\n    while (tween) {\n      var next = tween._next;\n      if (tween.target === target) {\n        Tween._register(tween, true)\n      }\n      tween = next\n    }\n    target.tweenjs_count = 0\n  };\n  /**\n   * Stop and remove all existing tweens.\n   * @method removeAllTweens\n   * @static\n   * @since 0.4.1\n   */\n  Tween.removeAllTweens = function removeAllTweens() {\n    var tween = Tween._tweenHead;\n    while (tween) {\n      var next = tween._next;\n      tween._paused = true;\n      tween.target && (tween.target.tweenjs_count = 0);\n      tween._next = tween._prev = null;\n      tween = next\n    }\n    Tween._tweenHead = Tween._tweenTail = null\n  };\n  /**\n   * Indicates whether there are any active tweens on the target object (if specified) or in general.\n   * @method hasActiveTweens\n   * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate\n   * if there are any active tweens on any target.\n   * @return {Boolean} Indicates if there are active tweens.\n   * @static\n   */\n  Tween.hasActiveTweens = function hasActiveTweens(target) {\n    if (target) {\n      return !!target.tweenjs_count\n    }\n    return !!Tween._tweenHead\n  };\n  /**\n   * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink \"SamplePlugin\"}}{{/crossLink}}\n   * for an example of how to write TweenJS plugins. Plugins should generally be installed via their own `install` method, in order to provide\n   * the plugin with an opportunity to configure itself.\n   * @method _installPlugin\n   * @param {Object} plugin The plugin to install\n   * @static\n   * @protected\n   */\n  Tween._installPlugin = function _installPlugin(plugin) {\n    var priority = plugin.priority,\n      arr = Tween._plugins;\n    if (priority == null) {\n      plugin.priority = priority = 0\n    }\n    if (!arr) {\n      arr = Tween._plugins = []\n    }\n    for (var _i = 0, l = arr.length; _i < l; _i++) {\n      if (priority < arr[_i].priority) {\n        break\n      }\n    }\n    arr.splice(i, 0, plugin)\n  };\n  /**\n   * Registers or unregisters a tween with the ticking system.\n   * @method _register\n   * @param {Tween} tween The tween instance to register or unregister.\n   * @param {Boolean} paused If `false`, the tween is registered. If `true` the tween is unregistered.\n   * @static\n   * @protected\n   */\n  Tween._register = function _register(tween, paused) {\n    var target = tween.target;\n    if (!paused && tween._paused) {\n      // TODO: this approach might fail if a dev is using sealed objects in ES5\n      if (target) {\n        target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count + 1 : 1\n      }\n      var tail = Tween._tweenTail;\n      if (!tail) {\n        Tween._tweenHead = Tween._tweenTail = tween\n      } else {\n        Tween._tweenTail = tail._next = tween;\n        tween._prev = tail\n      }\n      if (!Tween._inited) {\n        Ticker.addEventListener(\"tick\", Tween);\n        Tween._inited = true\n      }\n    } else if (paused && !tween._paused) {\n      if (target) {\n        target.tweenjs_count--\n      }\n      var next = tween._next,\n        prev = tween._prev;\n      if (next) {\n        next._prev = prev\n      } else {\n        Tween._tweenTail = prev\n      } // was tail\n      if (prev) {\n        prev._next = next\n      } else {\n        Tween._tweenHead = next\n      } // was head.\n      tween._next = tween._prev = null\n    }\n    tween._paused = paused\n  };\n  // public methods:\n  /**\n   * Adds a wait (essentially an empty tween).\n   * <h4>Example</h4>\n   *\n   *\t//This tween will wait 1s before alpha is faded to 0.\n   *\tcreatejs.Tween.get(target).wait(1000).to({alpha:0}, 1000);\n   *\n   * @method wait\n   * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).\n   * @param {Boolean} [passive=false] Tween properties will not be updated during a passive wait. This\n   * is mostly useful for use with {{#crossLink \"Timeline\"}}{{/crossLink}} instances that contain multiple tweens\n   * affecting the same target at different times.\n   * @return {Tween} This tween instance (for chaining calls).\n   * @chainable\n   */\n  Tween.prototype.wait = function wait(duration) {\n    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (duration > 0) {\n      this._addStep(duration, this._stepTail.props, null, passive)\n    }\n    return this\n  };\n  /**\n   * Adds a tween from the current values to the specified properties. Set duration to 0 to jump to these value.\n   * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric\n   * properties will be set at the end of the specified duration.\n   * <h4>Example</h4>\n   *\n   *\tcreatejs.Tween.get(target).to({alpha:0, visible:false}, 1000);\n   *\n   * @method to\n   * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x\n   * property of the target to 300).\n   * @param {Number} [duration=0] The duration of the tween in milliseconds (or in ticks if `useTicks` is true).\n   * @param {Function} [ease=\"linear\"] The easing function to use for this tween. See the {{#crossLink \"Ease\"}}{{/crossLink}}\n   * class for a list of built-in ease functions.\n   * @return {Tween} This tween instance (for chaining calls).\n   * @chainable\n   */\n  Tween.prototype.to = function to(props) {\n    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var ease = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n    if (duration < 0) {\n      duration = 0\n    }\n    var step = this._addStep(duration, null, ease);\n    this._appendProps(props, step);\n    return this\n  };\n  /**\n   * Adds a label that can be used with {{#crossLink \"Tween/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Tween/gotoAndStop\"}}{{/crossLink}}\n   * at the current point in the tween. For example:\n   *\n   * \tvar tween = createjs.Tween.get(foo)\n   * \t\t\t\t\t.to({x:100}, 1000)\n   * \t\t\t\t\t.label(\"myLabel\")\n   * \t\t\t\t\t.to({x:200}, 1000);\n   * // ...\n   * tween.gotoAndPlay(\"myLabel\"); // would play from 1000ms in.\n   *\n   * @method addLabel\n   * @param {String} label The label name.\n   * @param {Number} position The position this label represents.\n   * @return {Tween} This tween instance (for chaining calls).\n   * @chainable\n   */\n  Tween.prototype.label = function label(name) {\n    this.addLabel(name, this.duration);\n    return this\n  };\n  /**\n   * Adds an action to call the specified function.\n   * <h4>Example</h4>\n   *\n   * \t//would call myFunction() after 1 second.\n   * \tcreatejs.Tween.get().wait(1000).call(myFunction);\n   *\n   * @method call\n   * @param {Function} callback The function to call.\n   * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function\n   * will be called with a single param pointing to this tween.\n   * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's scope.\n   * @return {Tween} This tween instance (for chaining calls).\n   * @chainable\n   */\n  Tween.prototype.call = function call(callback, params, scope) {\n    return this._addAction(scope || this.target, callback, params || [this])\n  };\n  /**\n   * Adds an action to set the specified props on the specified target. If `target` is null, it will use this tween's\n   * target. Note that for properties on the target object, you should consider using a zero duration {{#crossLink \"Tween/to\"}}{{/crossLink}}\n   * operation instead so the values are registered as tweened props.\n   * <h4>Example</h4>\n   *\n   *\tmyTween.wait(1000).set({visible:false}, foo);\n   *\n   * @method set\n   * @param {Object} props The properties to set (ex. `{visible:false}`).\n   * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.\n   * @return {Tween} This tween instance (for chaining calls).\n   * @chainable\n   */\n  Tween.prototype.set = function set(props, target) {\n    return this._addAction(target || this.target, this._set, [props])\n  };\n  /**\n   * Adds an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.\n   * <h4>Example</h4>\n   *\n   *\tmyTween.to({x:100}, 500).play(otherTween);\n   *\n   * @method play\n   * @param {Tween} tween The tween to play.\n   * @return {Tween} This tween instance (for chaining calls).\n   * @chainable\n   */\n  Tween.prototype.play = function play(tween) {\n    return this.call(this.setPaused, [false], tween || this)\n  };\n  /**\n   * Adds an action to pause the specified tween.\n   *\n   * \tmyTween.pause(otherTween).to({alpha:1}, 1000).play(otherTween);\n   *\n   * @method pause\n   * @param {Tween} tween The tween to pause. If null, it pauses this tween.\n   * @return {Tween} This tween instance (for chaining calls)\n   * @chainable\n   */\n  Tween.prototype.pause = function pause(tween) {\n    return this.call(this.setPaused, [true], tween || this)\n  };\n  /**\n   * @method clone\n   * @protected\n   */\n  Tween.prototype.clone = function clone() {\n    throw \"Tween can not be cloned.\"\n  };\n  // private methods:\n  /**\n   * Adds a plugin to this tween.\n   * @method _addPlugin\n   * @param {Object} plugin\n   * @protected\n   */\n  Tween.prototype._addPlugin = function _addPlugin(plugin) {\n    var plugins = this._plugins,\n      priority = plugin.priority,\n      added = false;\n    if (!plugins) {\n      plugins = this._plugins = []\n    }\n    for (var _i2 = 0, l = plugins.length; _i2 < l; _i2++) {\n      if (plugins[_i2] === plugin) {\n        if (!added) {\n          return\n        } else {\n          plugins.splice(_i2, 1)\n        }\n      } else if (!added && priority < plugins[_i2].priority) {\n        plugins.splice(_i2, 0, plugin);\n        added = true\n      }\n    }\n    if (!added) {\n      plugins.push(plugin)\n    }\n  };\n  /**\n   * @method _updatePosition\n   * @override\n   */\n  Tween.prototype._updatePosition = function _updatePosition(jump, end) {\n    var step = this._stepHead.next,\n      t = this.position,\n      d = this.duration;\n    if (this.target && step) {\n      // find our new step index:\n      var stepNext = step.next;\n      while (stepNext && stepNext.t <= t) {\n        step = step.next;\n        stepNext = step.next\n      }\n      var ratio = end ? t / d : (t - step.t) / step.d; // TODO: revisit this.\n      this._updateTargetProps(step, ratio, end)\n    }\n    this._stepPosition = step ? t - step.t : 0\n  };\n  /**\n   * @method _updateTargetProps\n   * @param {Object} step\n   * @param {Number} ratio\n   * @param {Boolean} end Indicates to plugins that the full tween has ended.\n   * @protected\n   */\n  Tween.prototype._updateTargetProps = function _updateTargetProps(step, ratio, end) {\n    if (this.passive = !!step.passive) {\n      return\n    } // don't update props.\n    var v = void 0,\n      v0 = void 0,\n      v1 = void 0,\n      ease = void 0;\n    var p0 = step.prev.props;\n    var p1 = step.props;\n    if (ease = step.ease) {\n      ratio = ease(ratio, 0, 1, 1)\n    }\n    var plugins = this._plugins;\n    for (var n in p0) {\n      v = v0 = p0[n];\n      v1 = p1[n];\n      // values are different & it is numeric then interpolate:\n      if (v0 !== v1 && typeof v0 === \"number\") {\n        v = v0 + (v1 - v0) * ratio\n      }\n      if (plugins) {\n        for (var _i3 = 0, l = plugins.length; _i3 < l; _i3++) {\n          var value = plugins[_i3].tween(this, step, n, v, ratio, end);\n          if (v === Tween.IGNORE) {\n            return\n          }\n          if (value !== undefined) {\n            v = value\n          }\n        }\n      }\n      this.target[n] = v\n    }\n  };\n  /**\n   * @method _runActionsRange\n   * @param {Number} startPos\n   * @param {Number} endPos\n   * @param {Boolean} includeStart\n   * @protected\n   * @override\n   */\n  Tween.prototype._runActionsRange = function _runActionsRange(startPos, endPos, jump, includeStart) {\n    //console.log(\"\trange\", startPos, endPos, jump, includeStart);\n    var rev = startPos > endPos;\n    var action = rev ? this._actionTail : this._actionHead;\n    var ePos = endPos,\n      sPos = startPos;\n    if (rev) {\n      ePos = startPos;\n      sPos = endPos\n    }\n    var t = this.position;\n    while (action) {\n      var pos = action.t;\n      if (pos === endPos || pos > sPos && pos < ePos || includeStart && pos === startPos) {\n        //console.log(pos, \"start\", sPos, startPos, \"end\", ePos, endPos);\n        action.funct.apply(action.scope, action.params);\n        if (t !== this.position) {\n          return true\n        }\n      }\n      action = rev ? action.prev : action.next\n    }\n  };\n  /**\n   * @method _appendProps\n   * @param {Object} props\n   * @protected\n   */\n  Tween.prototype._appendProps = function _appendProps(props, step) {\n    var initProps = this._stepHead.props,\n      target = this.target,\n      plugins = Tween._plugins;\n    var inject = void 0,\n      ignored = void 0;\n    var oldStep = step.prev,\n      oldProps = oldStep.props;\n    var stepProps = step.props = this._cloneProps(oldProps);\n    for (var n in props) {\n      stepProps[n] = props[n];\n      if (initProps[n] !== undefined) {\n        continue\n      }\n      var oldValue = undefined; // accessing missing properties on DOMElements when using CSSPlugin is INSANELY expensive.\n      if (plugins) {\n        for (var _i4 = 0, l = plugins.length; _i4 < l; _i4++) {\n          var value = plugins[_i4].init(this, n, oldValue);\n          if (value !== undefined) {\n            oldValue = value\n          }\n          if (oldValue === Tween.IGNORE) {\n            (ignored = ignored || {})[n] = true;\n            delete stepProps[n];\n            break\n          }\n        }\n      }\n      if (oldValue !== Tween.IGNORE) {\n        if (oldValue === undefined) {\n          oldValue = target[n]\n        }\n        oldProps[n] = oldValue === undefined ? null : oldValue\n      }\n    }\n    plugins = this._plugins;\n    for (var _n in props) {\n      if (ignored && ignored[_n]) {\n        continue\n      }\n      var _value = props[_n];\n      // propagate old value to previous steps:\n      var o = void 0,\n        prev = oldStep;\n      while ((o = prev) && (prev = o.prev)) {\n        if (prev.props === o.props) {\n          continue\n        } // wait step\n        if (prev.props[_n] !== undefined) {\n          break\n        } // already has a value, we're done.\n        prev.props[_n] = oldProps[_n]\n      }\n      if (plugins) {\n        for (var _i5 = 0, _l = plugins.length; _i5 < _l; _i5++) {\n          var _value2 = plugins[_i5].step(this, step, _n, _value2);\n          if (_value2 !== undefined) {\n            step.props[_n] = _value2\n          }\n        }\n      }\n    }\n    if (inject = this._injected) {\n      this._injected = null;\n      this._appendProps(inject, step)\n    }\n  };\n  /**\n   * Used by plugins to inject properties. Called from within `Plugin.step` calls.\n   * @method _injectProps\n   * @param {Object} props\n   * @protected\n   */\n  Tween.prototype._injectProps = function _injectProps(props) {\n    var o = this._injected;\n    if (!this._injected) {\n      o = this._injected = {}\n    }\n    for (var n in props) {\n      o[n] = props[n]\n    }\n  };\n  /**\n   * @method _addStep\n   * @param {Number} duration\n   * @param {Object} props\n   * @param {Function} ease\n   * @param {Boolean} [passive=false]\n   * @protected\n   */\n  Tween.prototype._addStep = function _addStep(duration, props, ease) {\n    var passive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var step = new TweenStep(this._stepTail, this.duration, duration, props, ease, passive);\n    this.duration += duration;\n    return this._stepTail = this._stepTail.next = step\n  };\n  /**\n   * @method _addAction\n   * @param {Object} scope\n   * @param {Function} funct\n   * @param {Array} params\n   * @protected\n   */\n  Tween.prototype._addAction = function _addAction(scope, funct, params) {\n    var action = new TweenAction(this._actionTail, this.duration, scope, funct, params);\n    if (this._actionTail) {\n      this._actionTail.next = action\n    } else {\n      this._actionHead = action\n    }\n    this._actionTail = action;\n    return this\n  };\n  /**\n   * @method _set\n   * @param {Object} props\n   * @protected\n   */\n  Tween.prototype._set = function _set(props) {\n    for (var n in props) {\n      this[n] = props[n]\n    }\n  };\n  /**\n   * @method _cloneProps\n   * @param {Object} props\n   * @protected\n   */\n  Tween.prototype._cloneProps = function _cloneProps(props) {\n    var o = {};\n    for (var n in props) {\n      o[n] = props[n]\n    }\n    return o\n  };\n  return Tween\n}(AbstractTween); {\n  var p = Tween.prototype;\n  p.w = p.wait;\n  p.t = p.to;\n  p.c = p.call;\n  p.s = p.set\n}\n// static properties\n/**\n * Constant returned by plugins to tell the tween not to use default assignment.\n * @property IGNORE\n * @type Object\n * @static\n */\nTween.IGNORE = {};\n/**\n * @property _listeners\n * @type Array[Tween]\n * @static\n * @protected\n */\nTween._tweens = [];\n/**\n * @property _plugins\n * @type Object\n * @static\n * @protected\n */\nTween._plugins = null;\n/**\n * @property _tweenHead\n * @type Tween\n * @static\n * @protected\n */\nTween._tweenHead = null;\n/**\n * @property _tweenTail\n * @type Tween\n * @static\n * @protected\n */\nTween._tweenTail = null;\n// helpers:\nvar TweenStep = function TweenStep(prev, t, d, props, ease, passive) {\n  classCallCheck(this, TweenStep);\n  this.next = null;\n  this.prev = prev;\n  this.t = t;\n  this.d = d;\n  this.props = props;\n  this.ease = ease;\n  this.passive = passive;\n  this.index = prev ? prev.index + 1 : 0\n};\nvar TweenAction = function TweenAction(prev, t, scope, funct, params) {\n  classCallCheck(this, TweenAction);\n  this.next = null;\n  this.d = 0;\n  this.prev = prev;\n  this.t = t;\n  this.scope = scope;\n  this.funct = funct;\n  this.params = params\n};\n/**\n * Base class that both {{#crossLink \"Tween\"}}{{/crossLink}} and {{#crossLink \"Timeline\"}}{{/crossLink}} extend. Should not be instantiated directly.\n * @class AbstractTween\n * @param {Object} [props]\n * @extends EventDispatcher\n * @module TweenJS\n * @constructor\n */\nvar AbstractTween = function(_EventDispatcher) {\n  inherits(AbstractTween, _EventDispatcher);\n  // constructor:\n  /**\n   * @constructor\n   * @param {Object} [props]\n   */\n  function AbstractTween(props) {\n    classCallCheck(this, AbstractTween);\n    // public properties:\n    /**\n     * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink \"Ticker\"}}{{/crossLink}},\n     * then setting this to false (the default) will cause this tween to be paused when `Ticker.setPaused(true)`\n     * is called. See the {{#crossLink \"Tween/tick\"}}{{/crossLink}} method for more info. Can be set via the `props`\n     * parameter.\n     * @property ignoreGlobalPause\n     * @type Boolean\n     * @default false\n     */\n    var _this = possibleConstructorReturn(this, _EventDispatcher.call(this));\n    _this.ignoreGlobalPause = false;\n    /**\n     * Indicates the number of times to loop. If set to -1, the tween will loop continuously.\n     * @property loop\n     * @type {Number}\n     * @default 0\n     */\n    _this.loop = 0;\n    /**\n     * Uses ticks for all durations instead of milliseconds. This also changes the behaviour of some actions (such as `call`).\n     * Changing this value on a running tween could have unexpected results.\n     * @property useTicks\n     * @type {Boolean}\n     * @default false\n     * @readonly\n     */\n    _this.useTicks = false;\n    /**\n     * Causes the tween to play in reverse.\n     * @property reversed\n     * @type {Boolean}\n     * @default false\n     */\n    _this.reversed = false;\n    /**\n     * Causes the tween to reverse direction at the end of each loop.\n     * @property bounce\n     * @type {Boolean}\n     * @default false\n     */\n    _this.bounce = false;\n    /**\n     * Changes the rate at which the tween advances. For example, a `timeScale` value of `2` will double the\n     * playback speed, a value of `0.5` would halve it.\n     * @property timeScale\n     * @type {Number}\n     * @default 1\n     */\n    _this.timeScale = 1;\n    /**\n     * Indicates the duration of this tween in milliseconds (or ticks if `useTicks` is true), irrespective of `loops`.\n     * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected\n     * behaviour.\n     * @property duration\n     * @type {Number}\n     * @default 0\n     * @readonly\n     */\n    _this.duration = 0;\n    /**\n     * The current normalized position of the tween. This will always be a value between 0 and `duration`.\n     * Changing this property directly will have unexpected results, use {{#crossLink \"Tween/setPosition\"}}{{/crossLink}}.\n     * @property position\n     * @type {Object}\n     * @default 0\n     * @readonly\n     */\n    _this.position = 0;\n    /**\n     * The raw tween position. This value will be between `0` and `loops * duration` while the tween is active, or -1 before it activates.\n     * @property rawPosition\n     * @type {Number}\n     * @default -1\n     * @readonly\n     */\n    _this.rawPosition = -1;\n    // private properties:\n    /**\n     * @property _paused\n     * @type {Boolean}\n     * @default false\n     * @protected\n     */\n    _this._paused = true;\n    /**\n     * @property _next\n     * @type {Tween}\n     * @default null\n     * @protected\n     */\n    _this._next = null;\n    /**\n     * @property _prev\n     * @type {Tween}\n     * @default null\n     * @protected\n     */\n    _this._prev = null;\n    /**\n     * @property _parent\n     * @type {Object}\n     * @default null\n     * @protected\n     */\n    _this._parent = null;\n    /**\n     * @property _labels\n     * @type Object\n     * @protected\n     */\n    _this._labels = null;\n    /**\n     * @property _labelList\n     * @type Array[Object]\n     * @protected\n     */\n    _this._labelList = null;\n    if (props) {\n      _this.useTicks = !!props.useTicks;\n      _this.ignoreGlobalPause = !!props.ignoreGlobalPause;\n      _this.loop = props.loop === true ? -1 : props.loop || 0;\n      _this.reversed = !!props.reversed;\n      _this.bounce = !!props.bounce;\n      _this.timeScale = props.timeScale || 1;\n      props.onChange && _this.addEventListener(\"change\", props.onChange);\n      props.onComplete && _this.addEventListener(\"complete\", props.onComplete)\n    }\n    // while `position` is shared, it needs to happen after ALL props are set, so it's handled in _init()\n    return _this\n  }\n  // accessor properties:\n  /**\n   * Returns a list of the labels defined on this tween sorted by position.\n   * @property labels\n   * @return {Array[Object]} A sorted array of objects with label and position properties.\n   */\n  // public methods:\n  /**\n   * Advances the tween by a specified amount.\n   * @method advance\n   * @param {Number} delta The amount to advance in milliseconds (or ticks if useTicks is true). Negative values are supported.\n   * @param {Boolean} [ignoreActions=false] If true, actions will not be executed due to this change in position.\n   */\n  AbstractTween.prototype.advance = function advance(delta) {\n    var ignoreActions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.setPosition(this.rawPosition + delta * this.timeScale, ignoreActions)\n  };\n  /**\n   * Advances the tween to a specified position.\n   * @method setPosition\n   * @param {Number} rawPosition The raw position to seek to in milliseconds (or ticks if useTicks is true).\n   * @param {Boolean} [ignoreActions=false] If true, do not run any actions that would be triggered by this operation.\n   * @param {Boolean} [jump=false] If true, only actions at the new position will be run. If false, actions between the old and new position are run.\n   * @param {Function} [callback] Primarily for use with MovieClip, this callback is called after properties are updated, but before actions are run.\n   */\n  AbstractTween.prototype.setPosition = function setPosition(rawPosition) {\n    var ignoreActions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var jump = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var callback = arguments[3];\n    var d = this.duration,\n      loopCount = this.loop,\n      prevRawPos = this.rawPosition;\n    var loop = 0,\n      t = 0,\n      end = false;\n    // normalize position:\n    if (rawPosition < 0) {\n      rawPosition = 0\n    }\n    if (d === 0) {\n      // deal with 0 length tweens.\n      end = true;\n      if (prevRawPos !== -1) {\n        return end\n      }\n    } else {\n      loop = rawPosition / d | 0;\n      t = rawPosition - loop * d;\n      end = loopCount !== -1 && rawPosition >= loopCount * d + d;\n      if (end) {\n        rawPosition = (t = d) * (loop = loopCount) + d\n      }\n      if (rawPosition === prevRawPos) {\n        return end\n      } // no need to update\n      var rev = !this.reversed !== !(this.bounce && loop % 2); // current loop is reversed\n      if (rev) {\n        t = d - t\n      }\n    }\n    // set this in advance in case an action modifies position:\n    this.position = t;\n    this.rawPosition = rawPosition;\n    this._updatePosition(jump, end);\n    if (end) {\n      this.setPaused(true)\n    }\n    callback && callback(this);\n    if (!ignoreActions) {\n      this._runActions(prevRawPos, rawPosition, jump, !jump && prevRawPos === -1)\n    }\n    this.dispatchEvent(\"change\");\n    if (end) {\n      this.dispatchEvent(\"complete\")\n    }\n  };\n  /**\n   * Calculates a normalized position based on a raw position. For example, given a tween with a duration of 3000ms set to loop:\n   * \tconsole.log(myTween.calculatePosition(3700); // 700\n   * @method calculatePosition\n   * @param {Number} rawPosition A raw position.\n   */\n  AbstractTween.prototype.calculatePosition = function calculatePosition(rawPosition) {\n    // largely duplicated from setPosition, but necessary to avoid having to instantiate generic objects to pass values (end, loop, position) back.\n    var d = this.duration,\n      loopCount = this.loop,\n      loop = 0,\n      t = 0;\n    if (d === 0) {\n      return 0\n    }\n    if (loopCount !== -1 && rawPosition >= loopCount * d + d) {\n      t = d;\n      loop = loopCount\n    } else if (rawPosition < 0) {\n      t = 0\n    } else {\n      loop = rawPosition / d | 0;\n      t = rawPosition - loop * d\n    }\n    var rev = !this.reversed !== !(this.bounce && loop % 2); // current loop is reversed\n    return rev ? d - t : t\n  };\n  /**\n   * Adds a label that can be used with {{#crossLink \"Timeline/gotoAndPlay\"}}{{/crossLink}}/{{#crossLink \"Timeline/gotoAndStop\"}}{{/crossLink}}.\n   * @method addLabel\n   * @param {String} label The label name.\n   * @param {Number} position The position this label represents.\n   */\n  AbstractTween.prototype.addLabel = function addLabel(label, position) {\n    if (!this._labels) {\n      this._labels = {}\n    }\n    this._labels[label] = position;\n    var list = this._labelList;\n    if (list) {\n      for (var _i = 0, l = list.length; _i < l; _i++) {\n        if (position < list[_i].position) {\n          break\n        }\n      }\n      list.splice(i, 0, {\n        label: label,\n        position: position\n      })\n    }\n  };\n  /**\n   * Returns the name of the label on or immediately before the current position. For example, given a tween with\n   * two labels, \"first\" on frame index 4, and \"second\" on frame 8, getCurrentLabel would return:\n   * <UL>\n   * \t\t<LI>null if the current position is 2.</LI>\n   * \t\t<LI>\"first\" if the current position is 4.</LI>\n   * \t\t<LI>\"first\" if the current position is 7.</LI>\n   * \t\t<LI>\"second\" if the current position is 15.</LI>\n   * </UL>\n   * @method getCurrentLabel\n   * @return {String} The name of the current label or null if there is no label\n   */\n  AbstractTween.prototype.getCurrentLabel = function getCurrentLabel(pos) {\n    var labels = this.labels;\n    if (pos == null) {\n      pos = this.position\n    }\n    for (var _i2 = 0, l = labels.length; _i2 < l; _i2++) {\n      if (pos < labels[_i2].position) {\n        break\n      }\n    }\n    return i === 0 ? null : labels[i - 1].label\n  };\n  /**\n   * Unpauses this timeline and jumps to the specified position or label.\n   * @method gotoAndPlay\n   * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)\n   * or label to jump to.\n   */\n  AbstractTween.prototype.gotoAndPlay = function gotoAndPlay(positionOrLabel) {\n    this.setPaused(false);\n    this._goto(positionOrLabel)\n  };\n  /**\n   * Pauses this timeline and jumps to the specified position or label.\n   * @method gotoAndStop\n   * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label\n   * to jump to.\n   */\n  AbstractTween.prototype.gotoAndStop = function gotoAndStop(positionOrLabel) {\n    this.setPaused(true);\n    this._goto(positionOrLabel)\n  };\n  /**\n   * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the\n   * corresponding frame label will be returned, or `null` if a matching label is not defined.\n   * @method resolve\n   * @param {String|Number} positionOrLabel A numeric position value or label string.\n   */\n  AbstractTween.prototype.resolve = function resolve(positionOrLabel) {\n    var pos = Number(positionOrLabel);\n    if (isNaN(pos)) {\n      pos = this._labels && this._labels[positionOrLabel]\n    }\n    return pos\n  };\n  /**\n   * Pauses or plays this tween.\n   * @method setPaused\n   * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).\n   * @return {Tween} This tween instance (for chaining calls)\n   * @chainable\n   */\n  AbstractTween.prototype.setPaused = function setPaused(value) {\n    Tween._register(this, value);\n    return this\n  };\n  /**\n   * Returns a string representation of this object.\n   * @method toString\n   * @return {String} a string representation of the instance.\n   */\n  AbstractTween.prototype.toString = function toString() {\n    return \"[\" + this.constructor.name + (this.name ? \" (name=\" + this.name + \")\" : \"\") + \"]\"\n  };\n  /**\n   * @method clone\n   * @protected\n   */\n  AbstractTween.prototype.clone = function clone() {\n    throw \"AbstractTween can not be cloned.\"\n  };\n  // private methods:\n  /**\n   * Shared logic that executes at the end of the subclass constructor.\n   * @method _init\n   * @protected\n   */\n  AbstractTween.prototype._init = function _init(props) {\n    if (!props || !props.paused) {\n      this.setPaused(false)\n    }\n    if (props && props.position != null) {\n      this.setPosition(props.position)\n    }\n  };\n  /**\n   * @method _goto\n   * @protected\n   */\n  AbstractTween.prototype._goto = function _goto(positionOrLabel) {\n    var pos = this.resolve(positionOrLabel);\n    if (pos != null) {\n      this.setPosition(pos, false, true)\n    }\n  };\n  /**\n   * Runs actions between startPos & endPos. Separated to support action deferral.\n   * @method _runActions\n   * @protected\n   */\n  AbstractTween.prototype._runActions = function _runActions(startRawPos, endRawPos, jump, includeStart) {\n    // console.log(this.passive === false ? \" > Tween\" : \"Timeline\", \"run\", startRawPos, endRawPos, jump, includeStart);\n    // if we don't have any actions, and we're not a Timeline, then return:\n    // TODO: a cleaner way to handle this would be to override this method in Tween, but I'm not sure it's worth the overhead.\n    if (!this._actionHead && !this._tweens) {\n      return\n    }\n    var d = this.duration,\n      reversed = this.reversed,\n      bounce = this.bounce,\n      loopCount = this.loop;\n    var loop0 = void 0,\n      loop1 = void 0,\n      t0 = void 0,\n      t1 = void 0;\n    if (d === 0) {\n      // deal with 0 length tweens:\n      loop0 = loop1 = t0 = t1 = 0;\n      reversed = bounce = false\n    } else {\n      loop0 = startRawPos / d | 0;\n      loop1 = endRawPos / d | 0;\n      t0 = startRawPos - loop0 * d;\n      t1 = endRawPos - loop1 * d\n    }\n    // catch positions that are past the end:\n    if (loopCount !== -1) {\n      if (loop1 > loopCount) {\n        t1 = d;\n        loop1 = loopCount\n      }\n      if (loop0 > loopCount) {\n        t0 = d;\n        loop0 = loopCount\n      }\n    }\n    // special cases:\n    if (jump) {\n      return this._runActionsRange(t1, t1, jump, includeStart)\n    } else if (loop0 === loop1 && t0 === t1 && !jump) {\n      return\n    } else if (loop0 === -1) {\n      loop0 = t0 = 0\n    } // correct the -1 value for first advance, important with useTicks.\n    var dir = startRawPos <= endRawPos,\n      loop = loop0;\n    do {\n      var rev = !reversed !== !(bounce && loop % 2);\n      var start = loop === loop0 ? t0 : dir ? 0 : d;\n      var end = loop === loop1 ? t1 : dir ? d : 0;\n      if (rev) {\n        start = d - start;\n        end = d - end\n      }\n      if (bounce && loop !== loop0 && start === end) {} else if (this._runActionsRange(start, end, jump, includeStart || loop !== loop0 && !bounce)) {\n        return true\n      }\n      includeStart = false\n    } while (dir && ++loop <= loop1 || !dir && --loop >= loop1)\n  };\n  /**\n   * @method _runActionsRange\n   * @abstract\n   * @protected\n   */\n  AbstractTween.prototype._runActionsRange = function _runActionsRange(startPos, endPos, jump, includeStart) {};\n  AbstractTween.prototype._updatePosition = function _updatePosition(jump, end) {};\n  createClass(AbstractTween, [{\n    key: \"labels\",\n    get: function get() {\n      var list = this._labelList;\n      if (!list) {\n        list = this._labelList = [];\n        var labels = this._labels;\n        for (var label in labels) {\n          list.push({\n            label: label,\n            position: labels[label]\n          })\n        }\n        list.sort(function(a, b) {\n          return a.position - b.position\n        })\n      }\n      return list\n    },\n    set: function set(labels) {\n      this._labels = labels;\n      this._labelList = null\n    }\n  }]);\n  return AbstractTween\n}(EventDispatcher);\n/**\n * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a\n * timeline is looping, the tweens on it may appear to loop even if the \"loop\" property of the tween is false.\n *\n * NOTE: Timeline currently also accepts a param list in the form: `tweens, labels, props`. This is for backwards\n * compatibility only and will be removed in the future. Include tweens and labels as properties on the props object.\n * @class Timeline\n * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).\n * Supported props are listed below. These props are set on the corresponding instance properties except where\n * specified.<UL>\n *    <LI> `useTicks`</LI>\n *    <LI> `ignoreGlobalPause`</LI>\n *    <LI> `loop`</LI>\n *    <LI> `reversed`</LI>\n *    <LI> `bounce`</LI>\n *    <LI> `timeScale`</LI>\n *    <LI> `paused`: indicates whether to start the tween paused.</LI>\n *    <LI> `position`: indicates the initial position for this tween.</LI>\n *    <LI> `onChange`: adds the specified function as a listener to the `change` event</LI>\n *    <LI> `onComplete`: adds the specified function as a listener to the `complete` event</LI>\n * </UL>\n * @extends AbstractTween\n * @module TweenJS\n */\nvar Timeline = function(_AbstractTween) {\n  inherits(Timeline, _AbstractTween);\n  // constructor\n  /**\n   * @constructor\n   * @param {Object} props\n   */\n  function Timeline(props) {\n    classCallCheck(this, Timeline);\n    // private properties:\n    /**\n     * @property _tweens\n     * @type Array[Tween]\n     * @protected\n     */\n    var _this = possibleConstructorReturn(this, _AbstractTween.call(this, props));\n    _this._tweens = [];\n    if (props.tweens) {\n      _this.addTween.apply(_this, tweens)\n    }\n    _this.labels = props.labels;\n    _this._init(props);\n    return _this\n  }\n  // public methods:\n  /**\n   * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the\n   * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in\n   * unexpected behaviour.\n   * @method addTween\n   * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.\n   * @return {Tween} The first tween that was passed in.\n   */\n  Timeline.prototype.addTween = function addTween() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key]\n    }\n    var l = args.length;\n    if (l === 1) {\n      var _tween = args[0];\n      this._tweens.push(_tween);\n      _tween._parent = this;\n      _tween.setPaused(true);\n      var d = _tween.duration;\n      if (_tween.loop > 0) {\n        d *= _tween.loop + 1\n      }\n      if (d > this.duration) {\n        this.duration = d\n      }\n      if (this.rawPosition >= 0) {\n        _tween.setPosition(this.rawPosition)\n      }\n      return _tween\n    }\n    if (l > 1) {\n      for (var i = 0; i < l; i++) {\n        this.addTween(args[i])\n      }\n      return args[l - 1]\n    }\n    return null\n  };\n  /**\n   * Removes one or more tweens from this timeline.\n   * @method removeTween\n   * @param {Tween} ...args The tween(s) to remove. Accepts multiple arguments.\n   * @return Boolean Returns `true` if all of the tweens were successfully removed.\n   */\n  Timeline.prototype.removeTween = function removeTween() {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2]\n    }\n    var l = args.length;\n    if (l === 1) {\n      var _tweens = this._tweens;\n      var i = _tweens.length;\n      while (i--) {\n        if (_tweens[i] === tween) {\n          _tweens.splice(i, 1);\n          tween._parent = null;\n          if (tween.duration >= this.duration) {\n            this.updateDuration()\n          }\n          return true\n        }\n      }\n      return false\n    }\n    if (l > 1) {\n      var good = true;\n      for (var _i = 0; _i < l; _i++) {\n        good = good && this.removeTween(args[_i])\n      }\n      return good\n    }\n    return true\n  };\n  /**\n   * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,\n   * but this method is useful if you modify a tween after it was added to the timeline.\n   * @method updateDuration\n   */\n  Timeline.prototype.updateDuration = function updateDuration() {\n    this.duration = 0;\n    for (var i = 0, l = this._tweens.length; i < l; i++) {\n      var _tween2 = this._tweens[i];\n      var d = _tween2.duration;\n      if (_tween2.loop > 0) {\n        d *= _tween2.loop + 1\n      }\n      if (d > this.duration) {\n        this.duration = d\n      }\n    }\n  };\n  /**\n   * @method clone\n   * @protected\n   */\n  Timeline.prototype.clone = function clone() {\n    throw \"Timeline can not be cloned.\"\n  };\n  // private methods:\n  /**\n   * @method _updatePosition\n   * @override\n   */\n  Timeline.prototype._updatePosition = function _updatePosition(jump, end) {\n    var t = this.position;\n    for (var i = 0, l = this._tweens.length; i < l; i++) {\n      this._tweens[i].setPosition(t, true, jump)\n    }\n  };\n  /**\n   * @method _runActionsRange\n   * @override\n   */\n  Timeline.prototype._runActionsRange = function _runActionsRange(startPos, endPos, jump, includeStart) {\n    //console.log(\"\trange\", startPos, endPos, jump, includeStart);\n    var t = this.position;\n    for (var i = 0, l = this._tweens.length; i < l; i++) {\n      this._tweens[i]._runActions(startPos, endPos, jump, includeStart);\n      if (t !== this.position) {\n        return true\n      }\n    }\n  };\n  return Timeline\n}(AbstractTween);\n/**\n * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param\n * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.\n *\n * Most methods on Ease can be passed directly as easing functions:\n *\n *      Tween.get(target).to({x:100}, 500, Ease.linear);\n *\n * However, methods beginning with \"get\" will return an easing function based on parameter values:\n *\n *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));\n *\n * Please see the <a href=\"http://www.createjs.com/Demos/TweenJS/Tween_SparkTable\">spark table demo</a> for an\n * overview of the different ease types on <a href=\"http://tweenjs.com\">TweenJS.com</a>.\n *\n * <em>Equations derived from work by Robert Penner.</em>\n * @class Ease\n * @static\n * @module TweenJS\n */\nvar Ease = function() {\n  function Ease() {\n    classCallCheck(this, Ease);\n    throw \"Ease is static and cannot be instantiated.\"\n  }\n  // static methods:\n  /**\n   * @method linear\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.linear = function linear(t) {\n    return t\n  };\n  /**\n   * Mimics the simple -100 to 100 easing in Flash Pro.\n   * @method get\n   * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.\n   * @static\n   * @return {Function}\n   */\n  Ease.get = function get(amount) {\n    if (amount < -1) {\n      amount = -1\n    } else if (amount > 1) {\n      amount = 1\n    }\n    return function(t) {\n      if (amount == 0) {\n        return t\n      }\n      if (amount < 0) {\n        return t * (t * -amount + 1 + amount)\n      }\n      return t * ((2 - t) * amount + (1 - amount))\n    }\n  };\n  /**\n   * Configurable exponential ease.\n   * @method getPowIn\n   * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n   * @static\n   * @return {Function}\n   */\n  Ease.getPowIn = function getPowIn(pow) {\n    return function(t) {\n      return Math.pow(t, pow)\n    }\n  };\n  /**\n   * Configurable exponential ease.\n   * @method getPowOut\n   * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n   * @static\n   * @return {Function}\n   */\n  Ease.getPowOut = function getPowOut(pow) {\n    return function(t) {\n      return 1 - Math.pow(1 - t, pow)\n    }\n  };\n  /**\n   * Configurable exponential ease.\n   * @method getPowInOut\n   * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).\n   * @static\n   * @return {Function}\n   */\n  Ease.getPowInOut = function getPowInOut(pow) {\n    return function(t) {\n      if ((t *= 2) < 1) return .5 * Math.pow(t, pow);\n      return 1 - .5 * Math.abs(Math.pow(2 - t, pow))\n    }\n  };\n  /**\n   * @method sineIn\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.sineIn = function sineIn(t) {\n    return 1 - Math.cos(t * Math.PI / 2)\n  };\n  /**\n   * @method sineOut\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.sineOut = function sineOut(t) {\n    return Math.sin(t * Math.PI / 2)\n  };\n  /**\n   * @method sineInOut\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.sineInOut = function sineInOut(t) {\n    return -.5 * (Math.cos(Math.PI * t) - 1)\n  };\n  /**\n   * Configurable \"back in\" ease.\n   * @method getBackIn\n   * @param {Number} amount The strength of the ease.\n   * @static\n   * @return {Function}\n   */\n  Ease.getBackIn = function getBackIn(amount) {\n    return function(t) {\n      return t * t * ((amount + 1) * t - amount)\n    }\n  };\n  /**\n   * Configurable \"back out\" ease.\n   * @method getBackOut\n   * @param {Number} amount The strength of the ease.\n   * @static\n   * @return {Function}\n   */\n  Ease.getBackOut = function getBackOut(amount) {\n    return function(t) {\n      return --t * t * ((amount + 1) * t + amount) + 1\n    }\n  };\n  /**\n   * Configurable \"back in out\" ease.\n   * @method getBackInOut\n   * @param {Number} amount The strength of the ease.\n   * @static\n   * @return {Function}\n   */\n  Ease.getBackInOut = function getBackInOut(amount) {\n    amount *= 1.525;\n    return function(t) {\n      if ((t *= 2) < 1) return .5 * (t * t * ((amount + 1) * t - amount));\n      return .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2)\n    }\n  };\n  /**\n   * @method circIn\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.circIn = function circIn(t) {\n    return -(Math.sqrt(1 - t * t) - 1)\n  };\n  /**\n   * @method circOut\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.circOut = function circOut(t) {\n    return Math.sqrt(1 - --t * t)\n  };\n  /**\n   * @method circInOut\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.circInOut = function circInOut(t) {\n    if ((t *= 2) < 1) return -.5 * (Math.sqrt(1 - t * t) - 1);\n    return .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)\n  };\n  /**\n   * @method bounceIn\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.bounceIn = function bounceIn(t) {\n    return 1 - Ease.bounceOut(1 - t)\n  };\n  /**\n   * @method bounceOut\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.bounceOut = function bounceOut(t) {\n    if (t < 1 / 2.75) {\n      return 7.5625 * t * t\n    } else if (t < 2 / 2.75) {\n      return 7.5625 * (t -= 1.5 / 2.75) * t + .75\n    } else if (t < 2.5 / 2.75) {\n      return 7.5625 * (t -= 2.25 / 2.75) * t + .9375\n    } else {\n      return 7.5625 * (t -= 2.625 / 2.75) * t + .984375\n    }\n  };\n  /**\n   * @method bounceInOut\n   * @param {Number} t\n   * @static\n   * @return {Number}\n   */\n  Ease.bounceInOut = function bounceInOut(t) {\n    if (t < .5) return Ease.bounceIn(t * 2) * .5;\n    return Ease.bounceOut(t * 2 - 1) * .5 + .5\n  };\n  /**\n   * Configurable elastic ease.\n   * @method getElasticIn\n   * @param {Number} amplitude\n   * @param {Number} period\n   * @static\n   * @return {Function}\n   */\n  Ease.getElasticIn = function getElasticIn(amplitude, period) {\n    var pi2 = Math.PI * 2;\n    return function(t) {\n      if (t === 0 || t === 1) return t;\n      var s = period / pi2 * Math.asin(1 / amplitude);\n      return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period))\n    }\n  };\n  /**\n   * Configurable elastic ease.\n   * @method getElasticOut\n   * @param {Number} amplitude\n   * @param {Number} period\n   * @static\n   * @return {Function}\n   */\n  Ease.getElasticOut = function getElasticOut(amplitude, period) {\n    var pi2 = Math.PI * 2;\n    return function(t) {\n      if (t === 0 || t === 1) return t;\n      var s = period / pi2 * Math.asin(1 / amplitude);\n      return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1\n    }\n  };\n  /**\n   * Configurable elastic ease.\n   * @method getElasticInOut\n   * @param {Number} amplitude\n   * @param {Number} period\n   * @static\n   * @return {Function}\n   */\n  Ease.getElasticInOut = function getElasticInOut(amplitude, period) {\n    var pi2 = Math.PI * 2;\n    return function(t) {\n      var s = period / pi2 * Math.asin(1 / amplitude);\n      if ((t *= 2) < 1) return -.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));\n      return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * .5 + 1\n    }\n  };\n  return Ease\n}();\nEase.none = Ease.linear;\n/**\n * @method quadIn\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quadIn = Ease.getPowIn(2);\n/**\n * @method quadOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quadOut = Ease.getPowOut(2);\n/**\n * @method quadInOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quadInOut = Ease.getPowInOut(2);\n/**\n * @method cubicIn\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.cubicIn = Ease.getPowIn(3);\n/**\n * @method cubicOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.cubicOut = Ease.getPowOut(3);\n/**\n * @method cubicInOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.cubicInOut = Ease.getPowInOut(3);\n/**\n * @method quartIn\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quartIn = Ease.getPowIn(4);\n/**\n * @method quartOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quartOut = Ease.getPowOut(4);\n/**\n * @method quartInOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quartInOut = Ease.getPowInOut(4);\n/**\n * @method quintIn\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quintIn = Ease.getPowIn(5);\n/**\n * @method quintOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quintOut = Ease.getPowOut(5);\n/**\n * @method quintInOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.quintInOut = Ease.getPowInOut(5);\n/**\n * @method backIn\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.backIn = Ease.getBackIn(1.7);\n/**\n * @method backOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.backOut = Ease.getBackOut(1.7);\n/**\n * @method backInOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.backInOut = Ease.getBackInOut(1.7);\n/**\n * @method elasticIn\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.elasticIn = Ease.getElasticIn(1, .3);\n/**\n * @method elasticOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.elasticOut = Ease.getElasticOut(1, .3);\n/**\n * @method elasticInOut\n * @param {Number} t\n * @static\n * @return {Number}\n */\nEase.elasticInOut = Ease.getElasticInOut(1, .3 * 1.5);\n/**\n * A TweenJS plugin for working with numeric CSS string properties (ex. top, left). To use simply install after\n * TweenJS has loaded:\n *\n *      createjs.CSSPlugin.install();\n *\n * You can adjust the CSS properties it will work with by modifying the <code>cssSuffixMap</code> property. Currently,\n * the top, left, bottom, right, width, height have a \"px\" suffix appended.\n *\n * Please note that the CSS Plugin is not included in the TweenJS minified file.\n * @class CSSPlugin\n * @module TweenJS\n * @static\n */\nvar CSSPlugin = function() {\n  // constructor:\n  /**\n   * @constructor\n   */\n  function CSSPlugin() {\n    classCallCheck(this, CSSPlugin);\n    throw \"CSSPlugin is static and cannot be instanitated.\"\n  }\n  // static methods\n  /**\n   * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n   * @method install\n   * @static\n   */\n  CSSPlugin.prototype.install = function install() {\n    Tween._installPlugin(CSSPlugin)\n  };\n  /**\n   * @method init\n   * @protected\n   * @static\n   */\n  CSSPlugin.prototype.init = function init(tween, prop, value) {\n    var data = tween.pluginData;\n    if (data.CSS_disabled || !(tween.target instanceof HTMLElement)) {\n      return\n    }\n    var sfx0 = void 0,\n      sfx1 = void 0,\n      style = void 0,\n      map = CSSPlugin.cssSuffixMap;\n    if ((sfx0 = map[prop]) === undefined || !(style = tween.target.style)) {\n      return value\n    }\n    if (!data.CSS_installed) {\n      tween._addPlugin(CSSPlugin);\n      data.CSS_installed = true\n    }\n    var str = style[prop];\n    if (!str) {\n      return 0\n    } // no style set.\n    var i = str.length - sfx0.length;\n    if ((sfx1 = str.substr(i)) != sfx0) {\n      throw \"CSSPlugin Error: Suffixes do not match. (\" + sfx0 + \":\" + sfx1 + \")\"\n    } else {\n      return parseInt(str)\n    }\n  };\n  /**\n   * @method step\n   * @protected\n   * @static\n   */\n  CSSPlugin.prototype.step = function step(tween, _step, prop, value, injectProps) {};\n  CSSPlugin.prototype.tween = function tween(_tween, step, prop, value, ratio, end) {\n    var style = void 0,\n      map = CSSPlugin.cssSuffixMap,\n      sfx = map[prop];\n    if (sfx === undefined || !(style = _tween.target.style)) {\n      return\n    }\n    style[prop] = (value | 0) + sfx;\n    return Tween.IGNORE\n  };\n  return CSSPlugin\n}();\nCSSPlugin.cssSuffixMap = {\n  top: \"px\",\n  left: \"px\",\n  bottom: \"px\",\n  right: \"px\",\n  width: \"px\",\n  height: \"px\",\n  opacity: \"\"\n};\n/**\n * @property priority\n * @protected\n * @static\n */\nCSSPlugin.priority = -100; // very low priority, should run last\n/**\n * A TweenJS plugin for working with motion guides.\n *\n * To use, install the plugin after TweenJS has loaded. Next tween the 'guide' property with an object as detailed below.\n *\n *       createjs.MotionGuidePlugin.install();\n *\n * <h4>Example</h4>\n *\n *      // Using a Motion Guide\n *\t    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);\n *\t    // Visualizing the line\n *\t    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);\n *\n * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no\n * built in support for path changes mid tween. These are the Guide Object's properties:<UL>\n *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>\n *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>\n *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>\n *      <LI> orient: Optional, string : \"fixed\"/\"auto\"/\"cw\"/\"ccw\"<UL>\n *\t\t\t\t<LI>\"fixed\" forces the object to face down the path all movement (relative to start rotation),</LI>\n *      \t\t<LI>\"auto\" rotates the object along the path relative to the line.</LI>\n *      \t\t<LI>\"cw\"/\"ccw\" force clockwise or counter clockwise rotations including flash like behaviour</LI>\n * \t\t</UL></LI>\n * </UL>\n * Guide objects should not be shared between tweens even if all properties are identical, the library stores\n * information on these objects in the background and sharing them can cause unexpected behaviour. Values\n * outside 0-1 range of tweens will be a \"best guess\" from the appropriate part of the defined curve.\n *\n * @class MotionGuidePlugin\n * @module TweenJS\n * @static\n */\nvar MotionGuidePlugin = function() {\n  function MotionGuidePlugin() {\n    classCallCheck(this, MotionGuidePlugin);\n    throw \"MotionGuidePlugin is static and cannot be instantiated.\"\n  }\n  // static methods\n  /**\n   * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n   * @method install\n   * @static\n   */\n  MotionGuidePlugin.install = function install() {\n    Tween.installPlugin(MotionGuidePlugin, [\"guide\", \"x\", \"y\", \"rotation\"]);\n    return Tween.IGNORE\n  };\n  /**\n   * @method init\n   * @protected\n   * @static\n   */\n  MotionGuidePlugin.init = function init(tween, prop, value) {\n    var target = tween.target;\n    if (!target.hasOwnProperty(\"x\")) {\n      target.x = 0\n    }\n    if (!target.hasOwnProperty(\"y\")) {\n      target.y = 0\n    }\n    if (!target.hasOwnProperty(\"rotation\")) {\n      target.rotation = 0\n    }\n    if (prop === \"rotation\") {\n      tween.__needsRot = true\n    }\n    return prop === \"guide\" ? null : value\n  };\n  /**\n   * @method step\n   * @protected\n   * @static\n   */\n  MotionGuidePlugin.step = function step(tween, prop, startValue, endValue, injectProps) {\n    // other props\n    if (prop === \"rotation\") {\n      tween.__rotGlobalS = startValue;\n      tween.__rotGlobalE = endValue;\n      MotionGuidePlugin.testRotData(tween, injectProps)\n    }\n    if (prop !== \"guide\") {\n      return endValue\n    }\n    // guide only information - Start -\n    var temp = void 0,\n      data = endValue;\n    if (!data.hasOwnProperty(\"path\")) {\n      data.path = []\n    }\n    var path = data.path;\n    if (!data.hasOwnProperty(\"end\")) {\n      data.end = 1\n    }\n    if (!data.hasOwnProperty(\"start\")) {\n      data.start = startValue && startValue.hasOwnProperty(\"end\") && startValue.path === path ? startValue.end : 0\n    }\n    // Figure out subline information\n    if (data.hasOwnProperty(\"_segments\") && data._length) {\n      return endValue\n    }\n    var l = path.length;\n    var accuracy = 10; // Adjust to improve line following precision but sacrifice performance (# of seg)\n    if (l >= 6 && (l - 2) % 4 == 0) {\n      // Enough points && contains correct number per entry ignoring start\n      data._segments = [];\n      data._length = 0;\n      for (var i = 2; i < l; i += 4) {\n        var sx = path[i - 2],\n          sy = path[i - 1];\n        var cx = path[i + 0],\n          cy = path[i + 1];\n        var ex = path[i + 2],\n          ey = path[i + 3];\n        var oldX = sx,\n          oldY = sy;\n        var tempX = void 0,\n          tempY = void 0,\n          total = 0;\n        var sublines = [];\n        for (var _i = 1; _i <= accuracy; _i++) {\n          var t = _i / accuracy;\n          var inv = 1 - t;\n          tempX = inv * inv * sx + 2 * inv * t * cx + t * t * ex;\n          tempY = inv * inv * sy + 2 * inv * t * cy + t * t * ey;\n          total += sublines[sublines.push(Math.sqrt((temp = tempX - oldX) * temp + (temp = tempY - oldY) * temp)) - 1];\n          oldX = tempX;\n          oldY = tempY\n        }\n        data._segments.push(total, sublines);\n        data._length += total\n      }\n    } else {\n      throw \"invalid 'path' data, please see documentation for valid paths\"\n    }\n    // Setup x/y tweens\n    temp = data.orient;\n    data.orient = true;\n    var o = {};\n    MotionGuidePlugin.calc(data, data.start, o);\n    tween.__rotPathS = Number(o.rotation.toFixed(5));\n    MotionGuidePlugin.calc(data, data.end, o);\n    tween.__rotPathE = Number(o.rotation.toFixed(5));\n    data.orient = false; //here and now we don't know if we need to\n    MotionGuidePlugin.calc(data, data.end, injectProps);\n    data.orient = temp;\n    // Setup rotation properties\n    if (!data.orient) {\n      return endValue\n    }\n    tween.__guideData = data;\n    MotionGuidePlugin.testRotData(tween, injectProps);\n    return endValue\n  };\n  /**\n   * @method testRotData\n   * @protected\n   * @static\n   */\n  MotionGuidePlugin.testRotData = function testRotData(tween, injectProps) {\n    // no rotation informat? if we need it come back, if we don't use 0 & ensure we have guide data\n    if (tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined) {\n      if (tween.__needsRot) {\n        return\n      }\n      if (tween._curQueueProps.rotation !== undefined) {\n        tween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation\n      } else {\n        tween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0\n      }\n    }\n    if (tween.__guideData === undefined) {\n      return\n    }\n    // Process rotation properties\n    var data = tween.__guideData;\n    var rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;\n    var rotPathD = tween.__rotPathE - tween.__rotPathS;\n    var rot = rotGlobalD - rotPathD;\n    switch (data.orient) {\n      case \"auto\":\n        if (rot > 180) {\n          rot -= 360\n        } else if (rot < -180) {\n          rot += 360\n        }\n        break;\n      case \"cw\":\n        while (rot < 0) {\n          rot += 360\n        }\n        if (rot === 0 && rotGlobalD > 0 && rotGlobalD !== 180) {\n          rot += 360\n        }\n        break;\n      case \"ccw\":\n        rot = rotGlobalD - (rotPathD > 180 ? 360 - rotPathD : rotPathD); // sign flipping on path\n        while (rot > 0) {\n          rot -= 360\n        }\n        if (rot === 0 && rotGlobalD < 0 && rotGlobalD !== -180) {\n          rot -= 360\n        }\n        break\n    }\n    data.rotDelta = rot;\n    data.rotOffS = tween.__rotGlobalS - tween.__rotPathS;\n    // reset\n    tween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined\n  };\n  /**\n   * @method tween\n   * @protected\n   * @static\n   */\n  MotionGuidePlugin.tween = function tween(_tween, prop, value, startValues, endValues, ratio, wait, end) {\n    var data = endValues.guide;\n    if (data === undefined || data === startValues.guide) {\n      return value\n    }\n    if (data.lastRatio !== ratio) {\n      // first time through so calculate what I need to\n      var t = (data.end - data.start) * (wait ? data.end : ratio) + data.start;\n      MotionGuidePlugin.calc(data, t, _tween.target);\n      switch (data.orient) {\n        case \"cw\": // mix in the original rotation\n        case \"ccw\":\n        case \"auto\":\n          _tween.target.rotation += data.rotOffS + data.rotDelta * ratio;\n          break;\n        case \"fixed\": // follow fixed behaviour to solve potential issues\n        default:\n          _tween.target.rotation += data.rotOffS;\n          break\n      }\n      data.lastRatio = ratio\n    }\n    if (prop === \"rotation\" && (!data.orient || data.orient === \"false\")) {\n      return value\n    }\n    return _tween.target[prop]\n  };\n  /**\n   * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.\n   * Assumes a path object with all optional parameters specified.\n   * @param {Object} data Data object you would pass to the \"guide:\" property in a Tween\n   * @param {Number} ratio Distance along path, values outside 0-1 are \"best guess\"\n   * @param {Object} [target=false] to copy the results onto, will use a new object if not supplied.\n   * @return {Object} The target object or a new object w/ the tweened properties\n   * @static\n   */\n  MotionGuidePlugin.calc = function calc(data, ratio) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      x: 0,\n      y: 0,\n      rotation: 0\n    };\n    if (data._segments === undefined) {\n      MotionGuidePlugin.validate(data)\n    }\n    var seg = data._segments;\n    var path = data.path;\n    // find segment\n    var pos = data._length * ratio;\n    var cap = seg.length - 2;\n    var n = 0;\n    while (pos > seg[n] && n < cap) {\n      pos -= seg[n];\n      n += 2\n    }\n    // find subline\n    var sublines = seg[n + 1];\n    var i = 0;\n    cap = sublines.length - 1;\n    while (pos > sublines[i] && i < cap) {\n      pos -= sublines[i++]\n    }\n    var t = i / ++cap + pos / (cap * sublines[i]);\n    // find x/y\n    n += n + 2;\n    var inv = 1 - t;\n    target.x = inv * inv * path[n - 2] + 2 * inv * t * path[n + 0] + t * t * path[n + 2];\n    target.y = inv * inv * path[n - 1] + 2 * inv * t * path[n + 1] + t * t * path[n + 3];\n    // orientation\n    if (data.orient) {\n      target.rotation = 57.2957795 * Math.atan2((path[n + 1] - path[n - 1]) * inv + (path[n + 3] - path[n + 1]) * t, (path[n + 0] - path[n - 2]) * inv + (path[n + 2] - path[n + 0]) * t)\n    }\n    return target\n  };\n  return MotionGuidePlugin\n}();\nMotionGuidePlugin.priority = 0; // high priority, should run sooner\n/**\n * @property _rotOffS\n * @private\n * @static\n */\nMotionGuidePlugin._rotOffS = undefined;\n/**\n * @property _rotOffE\n * @private\n * @static\n */\nMotionGuidePlugin._rotOffE = undefined;\n/**\n * @property _rotNormS\n * @private\n * @static\n */\nMotionGuidePlugin._rotNormS = undefined;\n/**\n * @property _rotNormE\n * @private\n * @static\n */\nMotionGuidePlugin._rotNormE = undefined;\n/**\n * The RelativePlugin for TweenJS enables relative numeric values for tweens. Install using:\n *\n * \tRotationPlugin.install();\n *\n * Once installed, you can pass in relative numeric property values as strings beginning with \"+\" or \"-\". For example,\n * the following tween would tween the x position of `foo` from its initial value of `200` to `50` (200-150), then to\n * `125` (50+75).\n *\n * \tfoo.x = 200;\n * \tTween.get(foo).to({x:\"-150\"}, 500).to({x:\"+75\"}, 500);\n *\n * @class RelativePlugin\n * @module TweenJS\n * @static\n */\nvar RelativePlugin = function() {\n  // constructor:\n  /**\n   * @constructor\n   */\n  function RelativePlugin() {\n    classCallCheck(this, RelativePlugin);\n    throw \"RelativePlugin is static and cannot be instantiated.\"\n  }\n  // static methods:\n  /**\n   * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n   * @method install\n   * @static\n   */\n  RelativePlugin.prototype.install = function install() {\n    Tween._installPlugin(RelativePlugin)\n  };\n  /**\n   * Called by TweenJS when a new property initializes on a tween.\n   * See {{#crossLink \"SamplePlugin/init\"}}{{/crossLink}} for more info.\n   * @method init\n   * @param {Tween} tween\n   * @param {String} prop\n   * @param {any} value\n   * @return {any}\n   * @static\n   */\n  RelativePlugin.prototype.init = function init(tween, prop, value) {\n    var data = tween.pluginData;\n    if (!data.Relative_installed && !data.Relative_disabled) {\n      tween._addPlugin(s);\n      data.Relative_installed = true\n    }\n  };\n  /**\n   * Called when a new step is added to a tween (ie. a new \"to\" action is added to a tween).\n   * See {{#crossLink \"SamplePlugin/init\"}}{{/crossLink}} for more info.\n   * @method init\n   * @param {Tween} tween\n   * @param {TweenStep} step\n   * @param {String} prop\n   * @param {String} value\n   * @return {any}\n   * @static\n   */\n  RelativePlugin.prototype.step = function step(tween, _step, prop, value) {\n    if (typeof value !== \"string\") {\n      return\n    }\n    var prev = _step.prev.props[prop],\n      char0 = value[0],\n      val = void 0;\n    if (typeof prev !== \"number\" || !(char0 === \"+\" || char0 === \"-\") || isNaN(val = +value)) {\n      return\n    }\n    return prev + val\n  };\n  /**\n   * Called before a property is updated by the tween.\n   * See {{#crossLink \"SamplePlugin/init\"}}{{/crossLink}} for more info.\n   * @method tween\n   * @param {Tween} tween\n   * @param {TweenStep} step\n   * @param {String} prop\n   * @param {any} value\n   * @param {Number} ratio\n   * @param {Boolean} end\n   * @return {any}\n   * @static\n   */\n  RelativePlugin.prototype.tween = function tween(_tween, step, prop, value, ratio, end) {};\n  return RelativePlugin\n}();\n/**\n * The RotationPlugin for TweenJS modifies tweens of rotation properties. These properties can be changed using the\n * `RotationPlugin.props` property. Install using:\n *\n * \tRotationPlugin.install();\n *\n * After installation, by default all rotation tweens will rotate in the shortest direction. For example, if you\n * tween from `rotation=15` to `rotation=330`, it will rotate counter-clockwise. You can modify this behaviour by\n * specifying a `rotationDir` tween value. A value of `-1` will force CCW rotation, `1` will force CW, and `0` will\n * disable the plugin effects for that portion of the tween.\n *\n * Note that the `rotationDir` value will persist until overridden in future `to` calls.\n *\n * \t// this tween will rotate: CCW, then CCW (persisted), then CW.\n * \tmyTween.get(foo).to({rotation:30, rotationDir:-1}).to({rotation:60}).to({rotation:10, rotationDir:1});\n *\n * You can also disable the plugin completely for a tween by setting `tween.pluginData.Rotation_disabled=true`.\n *\n * @class RotationPlugin\n * @module TweenJS\n * @static\n */\nvar RotationPlugin = function() {\n  // constructor:\n  /**\n   * @constructor\n   */\n  function RotationPlugin() {\n    classCallCheck(this, RotationPlugin);\n    throw \"RotationPlugin is static and cannot be instantiated.\"\n  }\n  // static methods:\n  /**\n   * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n   * @method install\n   * @static\n   */\n  RotationPlugin.prototype.install = function install() {\n    Tween._installPlugin(RotationPlugin)\n  };\n  /**\n   * Called by TweenJS when a new property initializes on a tween.\n   * See {{#crossLink \"SamplePlugin/init\"}}{{/crossLink}} for more info.\n   * @method init\n   * @param {Tween} tween\n   * @param {String} prop\n   * @param {any} value\n   * @return {any}\n   * @static\n   */\n  RotationPlugin.prototype.init = function init(tween, prop, value) {\n    var data = tween.pluginData;\n    if (s.props[prop] && !data.Rotation_installed && !data.Rotation_disabled) {\n      tween._addPlugin(s);\n      data.Rotation_installed = true\n    }\n  };\n  /**\n   * Called when a new step is added to a tween (ie. a new \"to\" action is added to a tween).\n   * See {{#crossLink \"SamplePlugin/init\"}}{{/crossLink}} for more info.\n   * @method init\n   * @param {Tween} tween\n   * @param {TweenStep} step\n   * @param {String} prop\n   * @param {String} value\n   * @return {any}\n   * @static\n   */\n  RotationPlugin.prototype.step = function step(tween, _step, prop, value) {\n    if (!s.props[prop]) {\n      return\n    }\n    tween.pluginData.Rotation_end = value;\n    var dir = _step.props.rotationDir;\n    if (dir === 0) {\n      return\n    }\n    dir = dir || 0;\n    var start = _step.prev.props[prop];\n    var delta = (value - start) % 360;\n    if (dir === 0 && delta > 180 || dir === -1 && delta > 0) {\n      delta -= 360\n    } else if (dir === 0 && delta < -180 || dir === 1 && delta < 0) {\n      delta += 360\n    }\n    return start + delta\n  };\n  /**\n   * Called before a property is updated by the tween.\n   * See {{#crossLink \"SamplePlugin/init\"}}{{/crossLink}} for more info.\n   * @method tween\n   * @param {Tween} tween\n   * @param {TweenStep} step\n   * @param {String} prop\n   * @param {any} value\n   * @param {Number} ratio\n   * @param {Boolean} end\n   * @return {any}\n   * @static\n   */\n  RotationPlugin.prototype.tween = function tween(_tween, step, prop, value, ratio, end) {\n    if (prop === \"rotationDir\") {\n      return Tween.IGNORE\n    }\n    if (end && s.props[prop]) {\n      return _tween.pluginData.Rotation_end\n    }\n  };\n  return RotationPlugin\n}();\nRotationPlugin.props = {\n  rotation: 1,\n  rotationX: 1,\n  rotationY: 1,\n  rotationZ: 1\n};\n/**\n * A sample TweenJS plugin. This plugin does not actually affect tweens in any way, it's merely intended to document\n * how to build TweenJS plugins. Please look at the code for inline comments.\n *\n * A TweenJS plugin is simply an object that exposes one property (priority), and three methods (init, step, and tween).\n * Generally a plugin will also expose an <code>install</code> method as well, though this is not strictly necessary.\n * @class SamplePlugin\n * @module TweenJS\n * @static\n */\nvar SamplePlugin = function() {\n  // constructor:\n  /**\n   * @constructor\n   */\n  function SamplePlugin() {\n    classCallCheck(this, SamplePlugin);\n    throw \"SamplePlugin is static and cannot be instantiated.\"\n  }\n  // static methods:\n  /**\n   * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.\n   * @method install\n   * @static\n   */\n  SamplePlugin.install = function install() {\n    Tween._installPlugin(SamplePlugin)\n  };\n  /**\n   * Called by TweenJS when a new property initializes on a tween. Generally, the call\n   * to `Plugin.init` will be immediately followed by a call to `Plugin.step`.\n   *\n   * For example:\n   *\n   * \tTween.get(foo)\n   * \t\t.to({x:10}) // init called with prop = \"x\", value = 0\n   * \t\t.to({x:20}) // init is NOT called\n   * \t\t.to({y:200}) // init called with prop = \"y\", value = 100\n   *\n   * @method init\n   * @param {Tween} tween The related tween instance.\n   * @param {String} prop The name of the property that is being initialized.\n   * @param {any} value If another plugin has returned a starting value, it will be passed in. Otherwise value will be undefined.\n   * @return {any} The starting tween value for the property. In most cases, you would simply return the value parameter,\n   * but some plugins may need to modify the starting value. You can also return `Tween.IGNORE` to prevent this tween\n   * from being added to the tween.\n   * @static\n   */\n  SamplePlugin.init = function init(tween, prop, value) {\n    console.log(\"init: \", prop, value);\n    // its good practice to let users opt out (or in some cases, maybe in) via pluginData:\n    var data = tween.pluginData;\n    if (data.Sample_disabled) {\n      return value\n    } // make sure to pass through value.\n    // filter which properties you want to work on by using \"prop\":\n    if (prop !== \"x\" && prop !== \"y\") {\n      return value\n    } // make sure to pass through value.\n    // you can then add this plugin to the tween:\n    // Tween._addPlugin will screen for duplicate plugins, but its more efficient to set and check a flag:\n    if (!data.Sample_installed) {\n      data.Sample_installed = true; // don't install again if we init on the same tween twice.\n      // most plugins can just be a single shared plugin class:\n      tween._addPlugin(SamplePlugin)\n    }\n    // note that it's also possible to create a plugin that doesn't add itself, but hooks into the \"change\" event instead.\n    // you can grab the current value on the target using:\n    var targetValue = tween.target[prop];\n    // this would get the current starting value for the property, using value from previous plugins if specified, or the target value if not:\n    // this is a bit of a pain, but it prevents accessing target values that aren't needed, which can be very expensive (ex. width on a HTMLElement, when we actually want to grab it from style)\n    var defaultValue = value === undefined ? targetValue : value;\n    // this would round the starting value of \"x\" properties:\n    if (prop === \"x\") {\n      return Math.round(defaultValue)\n    }\n    // this would tell the tween to not include the \"y\" property:\n    // if (prop === \"y\") { return Tween.IGNORE }\n    // you can also use pluginData to attach arbitrary data to the tween for later use:\n    if (!data) {\n      data = tween.pluginData = {}\n    } // to reduce GC churn, pluginData is null by default.\n    data._Sample_value = 200; // namespacing your values will help prevent conflicts\n    // if you don't want to make changes, then makes sure to pass other plugins changes through:\n    return value\n  };\n  /**\n   * Called when a new step is added to a tween (ie. a new \"to\" action is added to a tween).\n   * For example:\n   *\n   * \tTween.get(foo)\n   * \t\t.to({x:10}) // step called with prop = \"x\"\n   * \t\t.to({y:100}) // step called with prop = \"y\"\n   * \t\t.to({x:20, y:200}) // step is called twice\n   *\n   * @method init\n   * @param {Tween} tween The related tween instance.\n   * @param {TweenStep} step The related tween step. This class is currently undocumented. See the bottom of Tween.js for info.\n   * @param {String} prop The name of the property being tweened.\n   * @param {String} value The value of the property for this step.\n   * @param {Object} injectProps If a previous plugin returned an injectProps object, it will be passed here.\n   * @return {Object} If you'd like to inject new properties into the tween, you can return a generic object with name value pairs. You should add to the existing injectProps object if it exists.\n   * @static\n   */\n  SamplePlugin.step = function step(tween, _step, prop, value, injectProps) {\n    console.log(\"step: \", _step, prop, injectProps);\n    // filter which properties you want to work on by using \"prop\":\n    if (prop !== \"x\") {\n      return\n    }\n    // you can grab the start value from previous step:\n    var startValue = _step.prev.props[prop]\n  };\n  /**\n   * Called before a property is updated by the tween.\n   * @method tween\n   * @param {Tween} tween The related tween instance.\n   * @param {TweenStep} step The related tween step. This class is currently undocumented. See the bottom of Tween.js for info.\n   * @param {String} prop The name of the property being tweened.\n   * @param {any} value The current tweened value of the property, as calculated by TweenJS. Previous plugins may have modified this value.\n   * @param {Number} ratio A value indicating the eased progress through the current step. This\n   * number is generally between 0 and 1, though some eases will generate values outside\n   * this range.\n   * @param {Boolean} end Indicates that the tween has reached the end.\n   * @return {any} Return the value that should be assigned to the target property.\n   * @static\n   */\n  SamplePlugin.tween = function tween(_tween, step, prop, value, ratio, end) {\n    // ratio is the eased ratio\n    console.log(\"tween\", step, prop, value, ratio, end);\n    // filter which properties you want to work on by using \"prop\":\n    if (prop !== \"x\") {\n      return value\n    } // make sure you ALWAYS pass through value!\n    // you can grab the end value for the step via its props object:\n    var endValue = step.props[prop];\n    // similarly, you can grab the start value from previous step:\n    var startValue = step.prev.props[prop];\n    // you could calculate the unmodified tweened value using the ratio:\n    // this will be the same as \"value\" unless a previous plugin returned a modified value\n    var unmodifiedValue = startValue + (endValue - startValue) * ratio;\n    if (value !== unmodifiedValue) {} /* a previous plugin modified the value */\n    // check if the tween is currently in a \"wait\" by comparing the props objects of this and the previous step:\n    var inWait = step.props === step.prev.props;\n    // tell the tween to not set the value on the target:\n    // return Tween.IGNORE;\n    // you can return a modified value to be set on the target:\n    return Math.round(value)\n  };\n  return SamplePlugin\n}();\nSamplePlugin.priority = 0;\n/**\n * The TweenJS JavaScript library provides a simple but powerful tweening interface. It supports tweening of both\n * numeric object properties & CSS style properties, and allows you to chain tweens and actions together to create\n * complex sequences.\n *\n * <h4>Simple Tween</h4>\n * This tween will tween the target's alpha property from 0 to 1 for 1s then call the <code>handleComplete</code> function.\n *\n *\t    target.alpha = 0;\n *\t    createjs.Tween.get(target).to({alpha:1}, 1000).call(handleComplete);\n *\t    function handleComplete() {\n *\t    \t//Tween complete\n *\t    }\n *\n * <strong>Arguments and Scope</strong>\n * Tween also supports a `call()` with arguments and/or a scope. If no scope is passed, then the function is called\n * anonymously (normal JavaScript behaviour). The scope is useful for maintaining scope when doing object-oriented\n * style development.\n *\n *      createjs.Tween.get(target).to({alpha:0})\n *          .call(handleComplete, [argument1, argument2], this);\n *\n * <h4>Chainable Tween</h4>\n * This tween will wait 0.5s, tween the target's alpha property to 0 over 1s, set it's visible to false, then call the\n * <code>handleComplete</code> function.\n *\n *\t    target.alpha = 1;\n *\t    createjs.Tween.get(target).wait(500).to({alpha:0, visible:false}, 1000).call(handleComplete);\n *\t    function handleComplete() {\n *\t    \t//Tween complete\n *\t    }\n *\n * <h4>Browser Support</h4>\n * TweenJS will work in all browsers.\n *\n * @module TweenJS\n * @main TweenJS\n */\n/**\n * README: Export Order\n *\n * Due to some classes having circular import bindings (whether at the top of the import chain or deeper in),\n * some exports here are in reverse order (such as Container being exported before DisplayObject).\n * This is explained here: https://github.com/rollup/rollup/issues/845#issuecomment-240277194\n */\n// re-export shared classes\n// TODO: Review this version export.\n// version (templated in gulpfile, pulled from package).\nvar version = \"1.0.0\";\nexports.version = version;\nexports.EventDispatcher = EventDispatcher;\nexports.Event = Event;\nexports.Ticker = Ticker;\nexports.AbstractTween = AbstractTween;\nexports.Tween = Tween;\nexports.Timeline = Timeline;\nexports.Ease = Ease;\nexports.CSSPlugin = CSSPlugin;\nexports.MotionGuidePlugin = MotionGuidePlugin;\nexports.RelativePlugin = RelativePlugin;\nexports.RotationPlugin = RotationPlugin;\nexports.SamplePlugin = SamplePlugin;"],"file":"tweenjs.cjs.js"}